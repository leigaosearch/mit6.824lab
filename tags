!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ACQUIRING	./lock_client_cache.h	/^  ACQUIRING,$/;"	e	enum:LOCKSTATUS
BUSY	./rsm_protocol.h	/^  enum xxstatus { OK, ERR, BUSY};$/;"	e	enum:rsm_protocol::xxstatus
BUSY	./rsm_protocol.h	/^  enum xxstatus { OK, ERR, NOTPRIMARY, BUSY};$/;"	e	enum:rsm_client_protocol::xxstatus
CB_MASK	./rpc/pollmgr.h	/^	CB_MASK = ~0x11,$/;"	e	enum:__anon6
CB_NONE	./rpc/pollmgr.h	/^	CB_NONE = 0x0,$/;"	e	enum:__anon6
CB_RDONLY	./rpc/pollmgr.h	/^	CB_RDONLY = 0x1,$/;"	e	enum:__anon6
CB_RDWR	./rpc/pollmgr.h	/^	CB_RDWR = 0x11,$/;"	e	enum:__anon6
CB_WRONLY	./rpc/pollmgr.h	/^	CB_WRONLY = 0x10,$/;"	e	enum:__anon6
CC	./GNUmakefile	/^CC = g++$/;"	m
CLOCK_MONOTONIC	./gettime.cc	/^	CLOCK_MONOTONIC,$/;"	e	enum:__anon2	file:
CLOCK_MONOTONIC	./gettime.h	/^	CLOCK_MONOTONIC,$/;"	e	enum:__anon1
CLOCK_PROCESS_CPUTIME_ID	./gettime.cc	/^	CLOCK_PROCESS_CPUTIME_ID,$/;"	e	enum:__anon2	file:
CLOCK_PROCESS_CPUTIME_ID	./gettime.h	/^	CLOCK_PROCESS_CPUTIME_ID,$/;"	e	enum:__anon1
CLOCK_REALTIME	./gettime.cc	/^	CLOCK_REALTIME,$/;"	e	enum:__anon2	file:
CLOCK_REALTIME	./gettime.h	/^	CLOCK_REALTIME,$/;"	e	enum:__anon1
CLOCK_THREAD_CPUTIME_ID	./gettime.cc	/^	CLOCK_THREAD_CPUTIME_ID$/;"	e	enum:__anon2	file:
CLOCK_THREAD_CPUTIME_ID	./gettime.h	/^	CLOCK_THREAD_CPUTIME_ID$/;"	e	enum:__anon1
CXX	./GNUmakefile	/^CXX = g++$/;"	m
CXXFLAGS	./GNUmakefile	/^CXXFLAGS =  -g -std=c++11 -MMD -Wall -I. -I$(RPC) -DLAB=$(LAB) -DSOL=$(SOL) -D_FILE_OFFSET_BITS=64$/;"	m
CacheLock	./lock_client_cache.h	/^struct CacheLock {$/;"	s
DEFAULT_RPC_SZ	./rpc/marshall.h	/^	DEFAULT_RPC_SZ = 1024,$/;"	e	enum:__anon5
DONE	./rpc/rpc.h	/^		DONE, \/\/ duplicate of an RPC we already replied to (have reply)$/;"	e	enum:rpcs::__anon4
EPollAIO	./rpc/pollmgr.cc	/^EPollAIO::EPollAIO()$/;"	f	class:EPollAIO
EPollAIO	./rpc/pollmgr.h	/^class EPollAIO : public aio_mgr {$/;"	c
ERR	./paxos_protocol.h	/^  enum xxstatus { OK, ERR };$/;"	e	enum:paxos_protocol::xxstatus
ERR	./rsm_protocol.h	/^  enum xxstatus { OK, ERR, BUSY};$/;"	e	enum:rsm_protocol::xxstatus
ERR	./rsm_protocol.h	/^  enum xxstatus { OK, ERR, NOTPRIMARY, BUSY};$/;"	e	enum:rsm_client_protocol::xxstatus
ERR	./rsm_protocol.h	/^  enum xxstatus { OK, ERR};$/;"	e	enum:rsm_test_protocol::xxstatus
EXIST	./yfs_client.h	/^  enum xxstatus { OK, RPCERR, NOENT, IOERR, EXIST };$/;"	e	enum:yfs_client::xxstatus
FAILURE	./config.h	/^    FAILURE,	\/\/ no response$/;"	e	enum:config::__anon7
FORGOTTEN	./rpc/rpc.h	/^		FORGOTTEN,  \/\/ duplicate of an old RPC whose reply we've forgotten$/;"	e	enum:rpcs::__anon4
FREE	./lock_client_cache.h	/^  FREE,$/;"	e	enum:LOCKSTATUS
FREE	./lock_server_cache.h	/^  FREE,$/;"	e	enum:lock_server_cache::lock_state
FUSEFLAGS	./GNUmakefile	/^FUSEFLAGS= -D_FILE_OFFSET_BITS=64 -DFUSE_USE_VERSION=25 -I\/usr\/local\/include\/fuse -I\/usr\/include\/fuse$/;"	m
INPROGRESS	./rpc/rpc.h	/^		INPROGRESS, \/\/ duplicate of an RPC we're still processing$/;"	e	enum:rpcs::__anon4
IOERR	./extent_protocol.h	/^  enum xxstatus { OK, RPCERR, NOENT, IOERR };$/;"	e	enum:extent_protocol::xxstatus
IOERR	./lock_protocol.h	/^  enum xxstatus { OK, RETRY, RPCERR, NOENT, IOERR };$/;"	e	enum:lock_protocol::xxstatus
IOERR	./yfs_client.h	/^  enum xxstatus { OK, RPCERR, NOENT, IOERR, EXIST };$/;"	e	enum:yfs_client::xxstatus
Instance	./rpc/pollmgr.cc	/^PollMgr::Instance()$/;"	f	class:PollMgr
JSL_DBG_1	./rpc/jsl_log.h	/^	JSL_DBG_1 = 1, \/\/ Critical$/;"	e	enum:dbcode
JSL_DBG_2	./rpc/jsl_log.h	/^	JSL_DBG_2 = 2, \/\/ Error$/;"	e	enum:dbcode
JSL_DBG_3	./rpc/jsl_log.h	/^	JSL_DBG_3 = 3, \/\/ Info$/;"	e	enum:dbcode
JSL_DBG_4	./rpc/jsl_log.h	/^	JSL_DBG_4 = 4, \/\/ Debugging$/;"	e	enum:dbcode
JSL_DBG_OFF	./rpc/jsl_log.h	/^	JSL_DBG_OFF = 0,$/;"	e	enum:dbcode
JSL_DEBUG_LEVEL	./rpc/jsl_log.cc	/^int JSL_DEBUG_LEVEL = 0;$/;"	v
LAB	./GNUmakefile	/^LAB=6$/;"	m
LAB2GE	./GNUmakefile	/^LAB2GE=$(shell expr $(LAB) \\>\\= 2)$/;"	m
LAB3GE	./GNUmakefile	/^LAB3GE=$(shell expr $(LAB) \\>\\= 3)$/;"	m
LAB4GE	./GNUmakefile	/^LAB4GE=$(shell expr $(LAB) \\>\\= 4)$/;"	m
LAB5GE	./GNUmakefile	/^LAB5GE=$(shell expr $(LAB) \\>\\= 5)$/;"	m
LAB6GE	./GNUmakefile	/^LAB6GE=$(shell expr $(LAB) \\>\\= 6)$/;"	m
LAB7GE	./GNUmakefile	/^LAB7GE=$(shell expr $(LAB) \\>\\= 7)$/;"	m
LDFLAGS	./GNUmakefile	/^LDFLAGS = -L. -L\/usr\/local\/lib$/;"	m
LDLIBS	./GNUmakefile	/^LDLIBS = -lpthread $/;"	m
LOCKED	./lock_client_cache.h	/^  LOCKED$/;"	e	enum:LOCKSTATUS
LOCKED	./lock_server_cache.h	/^  LOCKED,$/;"	e	enum:lock_server_cache::lock_state
LOCKSTATUS	./lock_client_cache.h	/^enum LOCKSTATUS {$/;"	g
MACFLAGS	./GNUmakefile	/^  MACFLAGS= -D__FreeBSD__=10$/;"	m
MACFLAGS	./GNUmakefile	/^  MACFLAGS=$/;"	m
MAX_PDU	./rpc/connection.cc	17;"	d	file:
MAX_POLL_FDS	./rpc/pollmgr.h	11;"	d
NEW	./rpc/rpc.h	/^		NEW,  \/\/ new RPC, not a duplicate$/;"	e	enum:rpcs::__anon4
NOENT	./extent_protocol.h	/^  enum xxstatus { OK, RPCERR, NOENT, IOERR };$/;"	e	enum:extent_protocol::xxstatus
NOENT	./lock_protocol.h	/^  enum xxstatus { OK, RETRY, RPCERR, NOENT, IOERR };$/;"	e	enum:lock_protocol::xxstatus
NOENT	./yfs_client.h	/^  enum xxstatus { OK, RPCERR, NOENT, IOERR, EXIST };$/;"	e	enum:yfs_client::xxstatus
NONE	./lock_client_cache.h	/^  NONE = 0,$/;"	e	enum:LOCKSTATUS
NOTPRIMARY	./rsm_protocol.h	/^  enum xxstatus { OK, ERR, NOTPRIMARY, BUSY};$/;"	e	enum:rsm_client_protocol::xxstatus
NUM_CL	./rpc/rpctest.cc	14;"	d	file:
OK	./config.h	/^    OK,	\/\/ response and same view #$/;"	e	enum:config::__anon7
OK	./extent_protocol.h	/^  enum xxstatus { OK, RPCERR, NOENT, IOERR };$/;"	e	enum:extent_protocol::xxstatus
OK	./lock_protocol.h	/^  enum xxstatus { OK, RETRY, RPCERR, NOENT, IOERR };$/;"	e	enum:lock_protocol::xxstatus
OK	./lock_protocol.h	/^  enum xxstatus { OK, RPCERR };$/;"	e	enum:rlock_protocol::xxstatus
OK	./paxos_protocol.h	/^  enum xxstatus { OK, ERR };$/;"	e	enum:paxos_protocol::xxstatus
OK	./rsm_protocol.h	/^  enum xxstatus { OK, ERR, BUSY};$/;"	e	enum:rsm_protocol::xxstatus
OK	./rsm_protocol.h	/^  enum xxstatus { OK, ERR, NOTPRIMARY, BUSY};$/;"	e	enum:rsm_client_protocol::xxstatus
OK	./rsm_protocol.h	/^  enum xxstatus { OK, ERR};$/;"	e	enum:rsm_test_protocol::xxstatus
OK	./yfs_client.h	/^  enum xxstatus { OK, RPCERR, NOENT, IOERR, EXIST };$/;"	e	enum:yfs_client::xxstatus
PollMgr	./rpc/pollmgr.cc	/^PollMgr::PollMgr() : pending_change_(false)$/;"	f	class:PollMgr
PollMgr	./rpc/pollmgr.h	/^class PollMgr {$/;"	c
PollMgrInit	./rpc/pollmgr.cc	/^PollMgrInit()$/;"	f
RELEASING	./lock_client_cache.h	/^  RELEASING,$/;"	e	enum:LOCKSTATUS
RETRY	./lock_protocol.h	/^  enum xxstatus { OK, RETRY, RPCERR, NOENT, IOERR };$/;"	e	enum:lock_protocol::xxstatus
RETRYING	./lock_server_cache.h	/^  RETRYING };$/;"	e	enum:lock_server_cache::lock_state
REVOKING	./lock_server_cache.h	/^  REVOKING,$/;"	e	enum:lock_server_cache::lock_state
RPC	./GNUmakefile	/^RPC=.\/rpc$/;"	m
RPCERR	./extent_protocol.h	/^  enum xxstatus { OK, RPCERR, NOENT, IOERR };$/;"	e	enum:extent_protocol::xxstatus
RPCERR	./lock_protocol.h	/^  enum xxstatus { OK, RETRY, RPCERR, NOENT, IOERR };$/;"	e	enum:lock_protocol::xxstatus
RPCERR	./lock_protocol.h	/^  enum xxstatus { OK, RPCERR };$/;"	e	enum:rlock_protocol::xxstatus
RPCERR	./yfs_client.h	/^  enum xxstatus { OK, RPCERR, NOENT, IOERR, EXIST };$/;"	e	enum:yfs_client::xxstatus
RPC_HEADER_SZ	./rpc/marshall.h	/^	RPC_HEADER_SZ = static_max<sizeof(req_header), sizeof(reply_header)>::value + sizeof(rpc_sz_t) + sizeof(rpc_checksum_t)$/;"	e	enum:__anon5
RSM	./lock_smain.cc	39;"	d	file:
SOL	./GNUmakefile	/^SOL=0$/;"	m
ScopedLock	./rpc/slock.h	/^		ScopedLock(pthread_mutex_t *m): m_(m) {$/;"	f	struct:ScopedLock
ScopedLock	./rpc/slock.h	/^struct ScopedLock {$/;"	s
SelectAIO	./rpc/pollmgr.cc	/^SelectAIO::SelectAIO() : highfds_(0)$/;"	f	class:SelectAIO
SelectAIO	./rpc/pollmgr.h	/^class SelectAIO : public aio_mgr {$/;"	c
TO	./rpc/rpc.h	/^		struct TO {$/;"	s	class:rpcc
TPRINTF_H	./tprintf.h	2;"	d
ThrPool	./rpc/thr_pool.cc	/^ThrPool::ThrPool(int sz, bool blocking)$/;"	f	class:ThrPool
ThrPool	./rpc/thr_pool.h	/^class ThrPool {$/;"	c
VERIFY	./lang/verify.h	10;"	d
VERIFY	./lang/verify.h	12;"	d
VIEWERR	./config.h	/^    VIEWERR,	\/\/ response but different view #$/;"	e	enum:config::__anon7
XXX	./rpc/method_thread.h	/^		class XXX {$/;"	c	namespace:__anon3
__JSL_LOG_H__	./rpc/jsl_log.h	2;"	d
__SCOPED_LOCK__	./rpc/slock.h	2;"	d
__THR_POOL__	./rpc/thr_pool.h	2;"	d
__clock_gettime_inf	./gettime.cc	/^static mach_timebase_info_data_t __clock_gettime_inf;$/;"	v	file:
_buf	./rpc/marshall.h	/^		char *_buf;     \/\/ Base of the raw bytes buffer (dynamically readjusted)$/;"	m	class:marshall
_buf	./rpc/marshall.h	/^		char *_buf;$/;"	m	class:unmarshall
_capa	./rpc/marshall.h	/^		int _capa;      \/\/ Capacity of the buffer$/;"	m	class:marshall
_ind	./rpc/marshall.h	/^		int _ind;       \/\/ Read\/write head position$/;"	m	class:marshall
_ind	./rpc/marshall.h	/^		int _ind;$/;"	m	class:unmarshall
_ok	./rpc/marshall.h	/^		bool _ok;$/;"	m	class:unmarshall
_sz	./rpc/marshall.h	/^		int _sz;$/;"	m	class:unmarshall
a	./lock_tester.cc	/^lock_protocol::lockid_t a = 1;$/;"	v
a	./rpc/thr_pool.h	/^			void *a; \/\/function arguments$/;"	m	struct:ThrPool::job_t
a1	./rpc/method_thread.h	/^				A1 a1;$/;"	m	class:__anon3::XXX
a2	./rpc/method_thread.h	/^				A2  a2;$/;"	m	class:__anon3::XXX
acc	./config.h	/^  acceptor *acc;$/;"	m	class:config
acc	./paxos.h	/^  acceptor *acc;$/;"	m	class:proposer
accept	./paxos_protocol.h	/^    bool accept;$/;"	m	struct:paxos_protocol::prepareres
accept_conn	./rpc/connection.cc	/^tcpsconn::accept_conn()$/;"	f	class:tcpsconn
acceptarg	./paxos_protocol.h	/^  struct acceptarg {$/;"	s	class:paxos_protocol
acceptor	./paxos.h	/^class acceptor {$/;"	c
acceptreq	./paxos_protocol.h	/^    acceptreq,$/;"	e	enum:paxos_protocol::rpc_numbers
acquire	./lock_client.cc	/^lock_client::acquire(lock_protocol::lockid_t lid)$/;"	f	class:lock_client
acquire	./lock_client_cache.cc	/^lock_client_cache::acquire(lock_protocol::lockid_t lid)$/;"	f	class:lock_client_cache
acquire	./lock_protocol.h	/^    acquire = 0x7001,$/;"	e	enum:lock_protocol::rpc_numbers
acquire	./lock_server.cc	/^lock_server::acquire(int clt,lock_protocol::lockid_t lid, int &r)$/;"	f	class:lock_server
acquire	./lock_server_cache.cc	/^int lock_server_cache::acquire(lock_protocol::lockid_t lid, std::string id, $/;"	f	class:lock_server_cache
add	./config.cc	/^config::add(std::string new_m, unsigned vid)$/;"	f	class:config
addJob	./rpc/thr_pool.cc	/^ThrPool::addJob(void *(*f)(void *), void *a)$/;"	f	class:ThrPool
addObjJob	./rpc/thr_pool.h	/^ThrPool::addObjJob(C *o, void (C::*m)(A), A a)$/;"	f	class:ThrPool
add_callback	./rpc/pollmgr.cc	/^PollMgr::add_callback(int fd, poll_flag flag, aio_callback *ch)$/;"	f	class:PollMgr
add_reply	./rpc/rpc.cc	/^rpcs::add_reply(unsigned int clt_nonce, unsigned int xid,$/;"	f	class:rpcs
add_timespec	./rpc/rpc.cc	/^add_timespec(const struct timespec &a, int b, struct timespec *result)$/;"	f
aio_	./rpc/pollmgr.h	/^		aio_mgr *aio_;$/;"	m	class:PollMgr
aio_callback	./rpc/pollmgr.h	/^class aio_callback {$/;"	c
aio_mgr	./rpc/pollmgr.h	/^class aio_mgr {$/;"	c
algorithm_h	./lang/algorithm.h	4;"	d
amiprimary	./rsm.cc	/^rsm::amiprimary()$/;"	f	class:rsm
append	./test-lab-2-b.pl	/^sub append {$/;"	s
append1	./test-lab-3-b.c	/^append1(const char *d, const char *f, const char *in)$/;"	f
append1	./test-lab-3-c.c	/^append1(const char *d, const char *f, const char *in)$/;"	f
atime	./extent_protocol.h	/^    unsigned int atime;$/;"	m	struct:extent_protocol::attr
atime	./yfs_client.h	/^    unsigned long atime;$/;"	m	struct:yfs_client::dirinfo
atime	./yfs_client.h	/^    unsigned long atime;$/;"	m	struct:yfs_client::fileinfo
atmostonce_failure	./rpc/rpc.h	/^		static const int atmostonce_failure = -4;$/;"	m	class:rpc_const
attr	./extent_protocol.h	/^  struct attr {$/;"	s	class:extent_protocol
attr	./extent_server.h	/^    extent_protocol::attr attr;$/;"	m	struct:extent_server::extent_value
attr	./rpc/rpctest.cc	/^pthread_attr_t attr;$/;"	v
attr_	./rpc/thr_pool.h	/^		pthread_attr_t attr_;$/;"	m	class:ThrPool
attribute	./extent_client.h	/^     extent_protocol::attr attribute;$/;"	m	struct:extent_client::extent_cachevalue
b	./lock_tester.cc	/^lock_protocol::lockid_t b = 2;$/;"	v
backups	./rsm.h	/^  std::vector<std::string> backups;   \/\/ A list of unsynchronized backups$/;"	m	class:rsm
big	./test-lab-3-b.c	/^char big[20001];$/;"	v
bind	./rpc/rpc.cc	/^rpcc::bind(TO to)$/;"	f	class:rpcc
bind	./rpc/rpc.h	/^		static const unsigned int bind = 1;   \/\/ handler number reserved for bind$/;"	m	class:rpc_const
bind_done_	./rpc/rpc.h	/^		bool bind_done_;$/;"	m	class:rpcc
bind_failure	./rpc/rpc.h	/^		static const int bind_failure = -6;$/;"	m	class:rpc_const
block_remove_fd	./rpc/pollmgr.cc	/^PollMgr::block_remove_fd(int fd)$/;"	f	class:PollMgr
blockadd_	./rpc/thr_pool.h	/^		bool blockadd_;$/;"	m	class:ThrPool
break1	./paxos.h	/^  bool break1;$/;"	m	class:proposer
break1	./rsm.h	/^  bool break1;$/;"	m	class:rsm
break2	./paxos.h	/^  bool break2;$/;"	m	class:proposer
break2	./rsm.h	/^  bool break2;$/;"	m	class:rsm
breakpoint	./config.h	/^  void breakpoint(int b) { pro->breakpoint(b); }$/;"	f	class:config
breakpoint	./rsm_protocol.h	/^    breakpoint = 0x12002,$/;"	e	enum:rsm_test_protocol::rpc_numbers
breakpoint	./rsmtest_client.cc	/^rsmtest_client::breakpoint(int b)$/;"	f	class:rsmtest_client
breakpoint1	./rsm.cc	/^rsm::breakpoint1()$/;"	f	class:rsm
breakpoint2	./rsm.cc	/^rsm::breakpoint2()$/;"	f	class:rsm
breakpointreq	./rsm.cc	/^rsm::breakpointreq(int b, int &r)$/;"	f	class:rsm
buf	./rpc/connection.h	/^			char *buf;$/;"	m	struct:connection::charbuf
buf	./rpc/rpc.h	/^		char *buf;      \/\/ the reply buffer$/;"	m	struct:rpcs::reply_t
buf	./rpc/rpc.h	/^		char *buf;$/;"	m	struct:rpcs::djob_t
buf	./rpc/rpc.h	/^                    std::string buf;$/;"	m	struct:rpcc::request
bundle	./rpc/connection.h	/^	bundle(chanmgr *m, int s, int l):mgr(m),tcp(s),lossy(l) {}$/;"	f	struct:bundle
bundle	./rpc/connection.h	/^struct bundle {$/;"	s
c	./lock_tester.cc	/^lock_protocol::lockid_t c = 3;$/;"	v
c	./rpc/rpc.h	/^			pthread_cond_t c;$/;"	m	struct:rpcc::caller
cachelocks	./lock_client_cache.h	/^  std::map<lock_protocol::lockid_t, CacheLock*> cachelocks;  $/;"	m	class:lock_client_cache
cachelocks	./lock_server_cache.h	/^  std::map<lock_protocol::lockid_t, lock_cache*> cachelocks;$/;"	m	class:lock_server_cache
cachelocksmutex	./lock_client_cache.h	/^  std::mutex cachelocksmutex;$/;"	m	class:lock_client_cache
cachemutex	./extent_client.h	/^  std::mutex cachemutex;$/;"	m	class:extent_client
call	./rpc/rpc.h	/^rpcc::call(unsigned int proc, R & r, TO to) $/;"	f	class:rpcc
call	./rpc/rpc.h	/^rpcc::call(unsigned int proc, const A1 & a1, R & r, TO to) $/;"	f	class:rpcc
call	./rpc/rpc.h	/^rpcc::call(unsigned int proc, const A1 & a1, const A2 & a2,$/;"	f	class:rpcc
call1	./rpc/rpc.cc	/^rpcc::call1(unsigned int proc, marshall &req, unmarshall &rep,$/;"	f	class:rpcc
call_m	./rpc/rpc.h	/^rpcc::call_m(unsigned int proc, marshall &req, R & r, TO to) $/;"	f	class:rpcc
callbacks_	./rpc/pollmgr.h	/^		aio_callback *callbacks_[MAX_POLL_FDS];$/;"	m	class:PollMgr
caller	./rpc/rpc.cc	/^  rpcc::caller::caller(unsigned int xxid, unmarshall *xun)$/;"	f	class:rpcc::caller
caller	./rpc/rpc.h	/^		struct caller {$/;"	s	class:rpcc
calls_	./rpc/rpc.h	/^		std::map<int, caller *> calls_;$/;"	m	class:rpcc
cancel	./rpc/rpc.cc	/^rpcc::cancel(void)$/;"	f	class:rpcc
cancel_failure	./rpc/rpc.h	/^		static const int cancel_failure = -7;$/;"	m	class:rpc_const
cb_present	./rpc/rpc.h	/^		bool cb_present; \/\/ whether the reply buffer is valid$/;"	m	struct:rpcs::reply_t
cfg	./paxos.h	/^  paxos_change *cfg;$/;"	m	class:acceptor
cfg	./paxos.h	/^  paxos_change *cfg;$/;"	m	class:proposer
cfg	./rsm.h	/^  config *cfg;$/;"	m	class:rsm
cfg_mutex	./config.h	/^  pthread_mutex_t cfg_mutex;$/;"	m	class:config
chan_	./rpc/rpc.h	/^		connection *chan_;$/;"	m	class:rpcc
chan_m_	./rpc/rpc.h	/^		pthread_mutex_t chan_m_;$/;"	m	class:rpcc
changedone_c_	./rpc/pollmgr.h	/^		pthread_cond_t changedone_c_;$/;"	m	class:PollMgr
chanmgr	./rpc/connection.h	/^class chanmgr {$/;"	c
channo	./rpc/connection.h	/^		int channo() { return fd_; }$/;"	f	class:connection
charbuf	./rpc/connection.h	/^			charbuf (char *b, int s) : buf(b), sz(s), solong(0){}$/;"	f	struct:connection::charbuf
charbuf	./rpc/connection.h	/^			charbuf(): buf(NULL), sz(0), solong(0) {}$/;"	f	struct:connection::charbuf
charbuf	./rpc/connection.h	/^		struct charbuf {$/;"	s	class:connection
check1	./test-lab-3-b.c	/^check1(const char *d, const char *f, const char *in)$/;"	f
check1	./test-lab-3-c.c	/^check1(const char *d, const char *f, const char *in)$/;"	f
check_grant	./lock_tester.cc	/^check_grant(lock_protocol::lockid_t lid)$/;"	f
check_release	./lock_tester.cc	/^check_release(lock_protocol::lockid_t lid)$/;"	f
check_views	./rsm_tester.pl	/^sub check_views {$/;"	s
checkcontent	./test-lab-2-b.pl	/^sub checkcontent {$/;"	s
checkdirmtime	./test-lab-3-a.pl	/^sub checkdirmtime {$/;"	s
checkduplicate_and_update	./rpc/rpc.cc	/^rpcs::checkduplicate_and_update(unsigned int clt_nonce, unsigned int xid,$/;"	f	class:rpcs
checkmtime	./test-lab-3-a.pl	/^sub checkmtime {$/;"	s
checkn	./test-lab-3-b.c	/^checkn(const char *d, const char *prefix, int nf)$/;"	f
checkn	./test-lab-3-c.c	/^checkn(const char *d, const char *prefix, int nf)$/;"	f
checknot	./test-lab-2-b.pl	/^sub checknot {$/;"	s
checknot	./test-lab-3-b.c	/^checknot(const char *d, const char *f)$/;"	f
checknot	./test-lab-3-c.c	/^checknot(const char *d, const char *f)$/;"	f
checkread	./test-lab-3-b.c	/^checkread(const char *d, const char *f, int start, int n, char c)$/;"	f
cl	./extent_client.h	/^  rpcc *cl;$/;"	m	class:extent_client
cl	./handle.h	/^  rpcc *cl;$/;"	m	struct:hinfo
cl	./lock_client.h	/^  rpcc *cl;$/;"	m	class:lock_client
cl	./rsmtest_client.h	/^  rpcc *cl;$/;"	m	class:rsmtest_client
cl_mutex	./handle.h	/^  pthread_mutex_t cl_mutex;$/;"	m	struct:hinfo
clean_files	./GNUmakefile	/^clean_files=rpc\/rpctest rpc\/*.o rpc\/*.d rpc\/librpc.a *.o *.d yfs_client extent_server lock_server lock_tester lock_demo rpctest test-lab-3-b test-lab-3-c rsm_tester$/;"	m
cleanup	./rsm_tester.pl	/^sub cleanup {$/;"	s
cleanup	./test-lab-3-a.pl	/^sub cleanup {$/;"	s
clear	./rpc/rpc.h	/^                    void clear() { buf.clear(); xid = -1; }$/;"	f	struct:rpcc::request
client1	./rpc/rpctest.cc	/^client1(void *xx)$/;"	f
client2	./rpc/rpctest.cc	/^client2(void *xx)$/;"	f
client3	./rpc/rpctest.cc	/^client3(void *xx)$/;"	f
client_invoke	./rsm.cc	/^rsm::client_invoke(int procno, std::string req, std::string &r)$/;"	f	class:rsm
client_members	./rsm.cc	/^rsm::client_members(int i, std::vector<std::string> &r)$/;"	f	class:rsm
clients	./rpc/rpctest.cc	/^rpcc *clients[NUM_CL];  \/\/ client rpc object$/;"	v
clock_gettime	./gettime.cc	/^int clock_gettime(clockid_t clk_id, struct timespec *tp) {$/;"	f
clock_gettime	./gettime.cc	65;"	d	file:
clockid_t	./gettime.cc	/^} clockid_t;$/;"	t	typeref:enum:__anon2	file:
clockid_t	./gettime.h	/^} clockid_t;$/;"	t	typeref:enum:__anon1
closeconn	./rpc/connection.cc	/^connection::closeconn()$/;"	f	class:connection
clt_nonce	./rpc/marshall.h	/^	unsigned int clt_nonce;$/;"	m	struct:req_header
clt_nonce_	./rpc/rpc.h	/^		unsigned int clt_nonce_;$/;"	m	class:rpcc
cmp_timespec	./rpc/rpc.cc	/^cmp_timespec(const struct timespec &a, const struct timespec &b)$/;"	f
commit_change	./rsm.cc	/^rsm::commit_change(unsigned vid) $/;"	f	class:rsm
commit_change_wo	./rsm.cc	/^rsm::commit_change_wo(unsigned vid) $/;"	f	class:rsm
compar	./test-lab-3-b.c	/^compar(const void *xa, const void *xb)$/;"	f
compar	./test-lab-3-c.c	/^compar(const void *xa, const void *xb)$/;"	f
compare	./rpc/connection.cc	/^connection::compare(connection *another)$/;"	f	class:connection
concurrent_test	./rpc/rpctest.cc	/^concurrent_test(int nt)$/;"	f
cond	./lock_server.h	/^  std::condition_variable cond;$/;"	m	class:lock_server
config	./config.cc	/^config::config(std::string _first, std::string _me, config_view_change *_vc) $/;"	f	class:config
config	./config.h	/^class config : public paxos_change {$/;"	c
config_cond	./config.h	/^  pthread_cond_t config_cond;$/;"	m	class:config
config_h	./config.h	2;"	d
config_view_change	./config.h	/^class config_view_change {$/;"	c
conn	./rpc/rpc.h	/^		connection *conn;$/;"	m	struct:rpcs::djob_t
connect_to_dst	./rpc/connection.cc	/^connect_to_dst(const sockaddr_in &dst, chanmgr *mgr, int lossy)$/;"	f
connection	./rpc/connection.cc	/^connection::connection(chanmgr *m1, int f1, int l1) $/;"	f	class:connection
connection	./rpc/connection.h	/^class connection : public aio_callback {$/;"	c
connection_h	./rpc/connection.h	2;"	d
conns_	./rpc/connection.h	/^		std::map<int, connection *> conns_;$/;"	m	class:tcpsconn
conns_	./rpc/rpc.h	/^	std::map<unsigned int, connection *> conns_;$/;"	m	class:rpcs
conss_m_	./rpc/rpc.h	/^	pthread_mutex_t conss_m_; \/\/ protect conns_$/;"	m	class:rpcs
content	./extent_client.h	/^     std::string content;$/;"	m	struct:extent_client::extent_cachevalue
count_m_	./rpc/rpc.h	/^	pthread_mutex_t count_m_;  \/\/protect modification of counts$/;"	m	class:rpcs
count_mutex	./lock_tester.cc	/^pthread_mutex_t count_mutex;$/;"	v
counting_	./rpc/rpc.h	/^	const int counting_;$/;"	m	class:rpcs
counts_	./rpc/rpc.h	/^	std::map<int, int> counts_;$/;"	m	class:rpcs
create	./yfs_client.cc	/^yfs_client::create(yfs_client::inum parent, const char * name, inum &fnum, bool isfile) {$/;"	f	class:yfs_client
create1	./test-lab-3-b.c	/^create1(const char *d, const char *f, const char *in)$/;"	f
create1	./test-lab-3-c.c	/^create1(const char *d, const char *f, const char *in)$/;"	f
create_time_	./rpc/connection.h	/^                struct timeval create_time_;$/;"	m	class:connection	typeref:struct:connection::timeval
createagain	./test-lab-2-a.pl	/^sub createagain {$/;"	s
createn	./test-lab-3-b.c	/^createn(const char *d, const char *prefix, int nf, bool possible_dup)$/;"	f
createn	./test-lab-3-c.c	/^createn(const char *d, const char *prefix, int nf)$/;"	f
createone	./test-lab-2-a.pl	/^sub createone {$/;"	s
createone	./test-lab-3-a.pl	/^sub createone {$/;"	s
cstr	./rpc/marshall.h	/^		char *cstr() { return _buf;}$/;"	f	class:marshall
cstr	./rpc/marshall.h	/^		char *cstr() { return _buf;}$/;"	f	class:unmarshall
ct	./lock_tester.cc	/^int ct[256];$/;"	v
ctime	./extent_protocol.h	/^    unsigned int ctime;$/;"	m	struct:extent_protocol::attr
ctime	./yfs_client.h	/^    unsigned long ctime;$/;"	m	struct:yfs_client::dirinfo
ctime	./yfs_client.h	/^    unsigned long ctime;$/;"	m	struct:yfs_client::fileinfo
curr_counts_	./rpc/rpc.h	/^	int curr_counts_;$/;"	m	class:rpcs
cv_mutex	./lock_server.h	/^  std::mutex cv_mutex;$/;"	m	class:lock_server
d1	./test-lab-3-b.c	/^char d1[512], d2[512];$/;"	v
d1	./test-lab-3-c.c	/^char d1[512], d2[512];$/;"	v
d2	./test-lab-3-b.c	/^char d1[512], d2[512];$/;"	v
d2	./test-lab-3-c.c	/^char d1[512], d2[512];$/;"	v
data	./extent_server.h	/^    std::string data;$/;"	m	struct:extent_server::extent_value
dbcode	./rpc/jsl_log.h	/^enum dbcode {$/;"	g
dead_	./rpc/connection.h	/^		bool dead_;$/;"	m	class:connection
deadcheck	./test-lab-2-a.pl	/^sub deadcheck {$/;"	s
deadcheck	./test-lab-3-a.pl	/^sub deadcheck {$/;"	s
decidearg	./paxos_protocol.h	/^  struct decidearg {$/;"	s	class:paxos_protocol
decidereq	./paxos_protocol.h	/^    decidereq,$/;"	e	enum:paxos_protocol::rpc_numbers
decref	./rpc/connection.cc	/^connection::decref()$/;"	f	class:connection
del	./handle.h	/^  bool del;$/;"	m	struct:hinfo
del_callback	./rpc/pollmgr.cc	/^PollMgr::del_callback(int fd, poll_flag flag)$/;"	f	class:PollMgr
delete_handle	./handle.cc	/^handle_mgr::delete_handle(std::string m)$/;"	f	class:handle_mgr
delete_handle_wo	./handle.cc	/^handle_mgr::delete_handle_wo(std::string m)$/;"	f	class:handle_mgr
deleteone	./test-lab-2-a.pl	/^sub deleteone {$/;"	s
deleteone	./test-lab-3-a.pl	/^sub deleteone {$/;"	s
deq	./rpc/fifo.h	/^fifo<T>::deq(T *e)$/;"	f	class:fifo
destroy_wait_	./rpc/rpc.h	/^		bool destroy_wait_;$/;"	m	class:rpcc
destroy_wait_c_	./rpc/rpc.h	/^		pthread_cond_t destroy_wait_c_;$/;"	m	class:rpcc
diff_timespec	./rpc/rpc.cc	/^diff_timespec(const struct timespec &end, const struct timespec &start)$/;"	f
dirbuf	./fuse.cc	/^struct dirbuf {$/;"	s	file:
dirbuf_add	./fuse.cc	/^void dirbuf_add(struct dirbuf *b, const char *name, fuse_ino_t ino)$/;"	f
dircheck	./test-lab-2-a.pl	/^sub dircheck {$/;"	s
dircheck	./test-lab-2-b.pl	/^sub dircheck {$/;"	s
dircheck	./test-lab-3-a.pl	/^sub dircheck {$/;"	s
dircheck	./test-lab-3-b.c	/^dircheck(const char *d, int nf)$/;"	f
dircheck	./test-lab-3-c.c	/^dircheck(const char *d, int nf)$/;"	f
dirent	./yfs_client.h	/^  struct dirent {$/;"	s	class:yfs_client
dirinfo	./yfs_client.h	/^  struct dirinfo {$/;"	s	class:yfs_client
dispatch	./rpc/rpc.cc	/^rpcs::dispatch(djob_t *j)$/;"	f	class:rpcs
dispatchpool_	./rpc/rpc.h	/^	ThrPool* dispatchpool_;$/;"	m	class:rpcs
djob_t	./rpc/rpc.h	/^		djob_t (connection *c, char *b, int bsz):buf(b),sz(bsz),conn(c) {}$/;"	f	struct:rpcs::djob_t
djob_t	./rpc/rpc.h	/^	struct djob_t {$/;"	s	class:rpcs
do_worker	./rpc/thr_pool.cc	/^do_worker(void *arg)$/;"	f	file:
doheartbeat	./config.cc	/^config::doheartbeat(std::string m)$/;"	f	class:config
done	./rpc/rpc.h	/^			bool done;$/;"	m	struct:rpcc::caller
done_handle	./handle.cc	/^handle_mgr::done_handle(struct hinfo *h)$/;"	f	class:handle_mgr
dopartition	./rsm.h	/^  bool dopartition;$/;"	m	class:rsm
dorelease	./yfs_client.cc	/^    virtual void dorelease(lock_protocol::lockid_t id) {$/;"	f	class:mylock_release_user
dst	./lock_demo.cc	/^std::string dst;$/;"	v
dst	./lock_tester.cc	/^std::string dst;$/;"	v
dst	./rpc/rpctest.cc	/^struct sockaddr_in dst; \/\/server's ip address$/;"	v	typeref:struct:sockaddr_in
dst_	./rpc/rpc.h	/^		sockaddr_in dst_;$/;"	m	class:rpcc
dump	./config.h	/^  std::string dump() { return acc->dump(); };$/;"	f	class:config
dump	./log.cc	/^log::dump()$/;"	f	class:log
dup_req_	./rpc/rpc.h	/^                struct request dup_req_;$/;"	m	class:rpcc	typeref:struct:rpcc::request
ec	./yfs_client.cc	/^    extent_client *ec;$/;"	m	class:mylock_release_user	file:
ec	./yfs_client.h	/^  extent_client *ec;$/;"	m	class:yfs_client
enq	./rpc/fifo.h	/^fifo<T>::enq(T e, bool blocking)$/;"	f	class:fifo
extent_cache	./extent_client.h	/^  std::map<extent_protocol::extentid_t, extent_cachevalue*> extent_cache;$/;"	m	class:extent_client
extent_cachevalue	./extent_client.h	/^  struct extent_cachevalue{$/;"	s	class:extent_client
extent_client	./extent_client.cc	/^extent_client::extent_client(std::string dst)$/;"	f	class:extent_client
extent_client	./extent_client.h	/^class extent_client {$/;"	c
extent_client_h	./extent_client.h	4;"	d
extent_protocol	./extent_protocol.h	/^class extent_protocol {$/;"	c
extent_protocol_h	./extent_protocol.h	4;"	d
extent_server	./GNUmakefile	/^extent_server=extent_server.cc extent_smain.cc$/;"	m
extent_server	./extent_server.cc	/^extent_server::extent_server() {}$/;"	f	class:extent_server
extent_server	./extent_server.h	/^class extent_server {$/;"	c
extent_server_h	./extent_server.h	4;"	d
extent_value	./extent_server.h	/^  struct extent_value {$/;"	s	class:extent_server
extentattrs	./extent_server.h	/^  std::map<extent_protocol::extentid_t, extent_protocol::attr> extentattrs;$/;"	m	class:extent_server
extentid_t	./extent_protocol.h	/^  typedef unsigned long long extentid_t;$/;"	t	class:extent_protocol
f	./rpc/thr_pool.h	/^			void *(*f)(void *); \/\/function point$/;"	m	struct:ThrPool::job_t
failure_test	./rpc/rpctest.cc	/^failure_test()$/;"	f
fd_	./rpc/connection.h	/^		const int fd_;$/;"	m	class:connection
fdstatus_	./rpc/pollmgr.h	/^		int fdstatus_[MAX_POLL_FDS];$/;"	m	class:EPollAIO
fifo	./rpc/fifo.h	/^class fifo {$/;"	c
fifo	./rpc/fifo.h	/^fifo<T>::fifo(int limit) : max_(limit)$/;"	f	class:fifo
fifo_h	./rpc/fifo.h	2;"	d
fileinfo	./yfs_client.h	/^  struct fileinfo {$/;"	s	class:yfs_client
filename	./yfs_client.cc	/^yfs_client::filename(inum inum)$/;"	f	class:yfs_client
files	./extent_server.h	/^  std::map<extent_protocol::extentid_t, std::string> files;$/;"	m	class:extent_server
first	./config.h	/^  std::string first;$/;"	m	class:config
flush	./extent_client.cc	/^extent_client::flush(extent_protocol::extentid_t eid) {$/;"	f	class:extent_client
free_reply_window	./rpc/rpc.cc	/^rpcs::free_reply_window(void)$/;"	f	class:rpcs
fuseserver_create	./fuse.cc	/^fuseserver_create(fuse_req_t req, fuse_ino_t parent, const char *name,$/;"	f
fuseserver_createhelper	./fuse.cc	/^fuseserver_createhelper(fuse_ino_t parent, const char *name,$/;"	f
fuseserver_getattr	./fuse.cc	/^fuseserver_getattr(fuse_req_t req, fuse_ino_t ino,$/;"	f
fuseserver_lookup	./fuse.cc	/^fuseserver_lookup(fuse_req_t req, fuse_ino_t parent, const char *name)$/;"	f
fuseserver_mkdir	./fuse.cc	/^fuseserver_mkdir(fuse_req_t req, fuse_ino_t parent, const char *name,$/;"	f
fuseserver_mknod	./fuse.cc	/^void fuseserver_mknod( fuse_req_t req, fuse_ino_t parent, $/;"	f
fuseserver_open	./fuse.cc	/^fuseserver_open(fuse_req_t req, fuse_ino_t ino,$/;"	f
fuseserver_oper	./fuse.cc	/^struct fuse_lowlevel_ops fuseserver_oper;$/;"	v	typeref:struct:fuse_lowlevel_ops
fuseserver_read	./fuse.cc	/^fuseserver_read(fuse_req_t req, fuse_ino_t ino, size_t size,$/;"	f
fuseserver_readdir	./fuse.cc	/^fuseserver_readdir(fuse_req_t req, fuse_ino_t ino, size_t size,$/;"	f
fuseserver_setattr	./fuse.cc	/^fuseserver_setattr(fuse_req_t req, fuse_ino_t ino, struct stat *attr,$/;"	f
fuseserver_statfs	./fuse.cc	/^fuseserver_statfs(fuse_req_t req)$/;"	f
fuseserver_unlink	./fuse.cc	/^fuseserver_unlink(fuse_req_t req, fuse_ino_t parent, const char *name)$/;"	f
fuseserver_write	./fuse.cc	/^fuseserver_write(fuse_req_t req, fuse_ino_t ino,$/;"	f
get	./extent_client.cc	/^extent_client::get(extent_protocol::extentid_t eid, std::string &buf)$/;"	f	class:extent_client
get	./extent_protocol.h	/^    get,$/;"	e	enum:extent_protocol::rpc_numbers
get	./extent_server.cc	/^int extent_server::get(extent_protocol::extentid_t id, std::string &buf)$/;"	f	class:extent_server
get_content	./rpc/marshall.h	/^		std::string get_content() { $/;"	f	class:marshall
get_handle	./handle.cc	/^handle_mgr::get_handle(std::string m)$/;"	f	class:handle_mgr
get_instance_h	./paxos.h	/^  unsigned get_instance_h() { return instance_h; };$/;"	f	class:acceptor
get_n_h	./paxos.h	/^  prop_t get_n_h() { return n_h; };$/;"	f	class:acceptor
get_num_views	./rsm_tester.pl	/^sub get_num_views {$/;"	s
get_refconn	./rpc/rpc.cc	/^rpcc::get_refconn(connection **ch)$/;"	f	class:rpcc
get_rpcs	./config.h	/^  rpcs *get_rpcs() { return acc->get_rpcs(); }$/;"	f	class:config
get_rpcs	./paxos.h	/^  rpcs *get_rpcs() { return pxs; };$/;"	f	class:acceptor
get_view	./config.cc	/^config::get_view(unsigned instance)$/;"	f	class:config
get_view_wo	./config.cc	/^config::get_view_wo(unsigned instance)$/;"	f	class:config
getattr	./extent_client.cc	/^extent_client::getattr(extent_protocol::extentid_t eid, $/;"	f	class:extent_client
getattr	./extent_protocol.h	/^    getattr,$/;"	e	enum:extent_protocol::rpc_numbers
getattr	./extent_server.cc	/^int extent_server::getattr(extent_protocol::extentid_t id, extent_protocol::attr &a)$/;"	f	class:extent_server
getattr	./fuse.cc	/^getattr(yfs_client::inum inum, struct stat &st)$/;"	f
getdir	./yfs_client.cc	/^yfs_client::getdir(inum inum, dirinfo &din)$/;"	f	class:yfs_client
getdirdata	./yfs_client.cc	/^int yfs_client::getdirdata(inum inum, std::string & content){$/;"	f	class:yfs_client
getfile	./yfs_client.cc	/^yfs_client::getfile(inum inum, fileinfo &fin)$/;"	f	class:yfs_client
gettime_h	./gettime.h	2;"	d
got_pdu	./rpc/rpc.cc	/^rpcc::got_pdu(connection *c, char *b, int sz)$/;"	f	class:rpcc
got_pdu	./rpc/rpc.cc	/^rpcs::got_pdu(connection *c, char *b, int sz)$/;"	f	class:rpcs
h	./handle.h	/^  struct hinfo *h;$/;"	m	class:handle	typeref:struct:handle::hinfo
handin_file	./GNUmakefile	/^handin_file=$(shell whoami)-lab$(LAB).tgz$/;"	m
handin_ignore	./GNUmakefile	/^handin_ignore=$(clean_files) core* *log$/;"	m
handle	./handle.cc	/^handle::handle(std::string m) $/;"	f	class:handle
handle	./handle.h	/^class handle {$/;"	c
handle_22	./rpc/rpctest.cc	/^srv::handle_22(const std::string a, std::string b, std::string &r)$/;"	f	class:srv
handle_bigrep	./rpc/rpctest.cc	/^srv::handle_bigrep(const int len, std::string &r)$/;"	f	class:srv
handle_fast	./rpc/rpctest.cc	/^srv::handle_fast(const int a, int &r)$/;"	f	class:srv
handle_h	./handle.h	24;"	d
handle_mgr	./handle.cc	/^handle_mgr::handle_mgr()$/;"	f	class:handle_mgr
handle_mgr	./handle.h	/^class handle_mgr {$/;"	c
handle_mutex	./handle.h	/^  pthread_mutex_t handle_mutex;$/;"	m	class:handle_mgr
handle_slow	./rpc/rpctest.cc	/^srv::handle_slow(const int a, int &r)$/;"	f	class:srv
handler	./rpc/rpc.h	/^		handler() { }$/;"	f	class:handler
handler	./rpc/rpc.h	/^class handler {$/;"	c
has_callback	./rpc/pollmgr.cc	/^PollMgr::has_callback(int fd, poll_flag flag, aio_callback *c)$/;"	f	class:PollMgr
has_space_c_	./rpc/fifo.h	/^		pthread_cond_t has_space_c_; \/\/ q is not longer overfull$/;"	m	class:fifo
heartbeat	./config.cc	/^config::heartbeat(std::string m, unsigned vid, int &r)$/;"	f	class:config
heartbeat	./paxos_protocol.h	/^    heartbeat,$/;"	e	enum:paxos_protocol::rpc_numbers
heartbeat_cond	./config.h	/^  pthread_cond_t heartbeat_cond;$/;"	m	class:config
heartbeat_t	./config.h	/^  } heartbeat_t;$/;"	t	class:config	typeref:enum:config::__anon7
heartbeater	./config.cc	/^config::heartbeater()$/;"	f	class:config
heartbeatthread	./config.cc	/^heartbeatthread(void *x)$/;"	f	file:
hfiles1	./GNUmakefile	/^hfiles1=rpc\/fifo.h rpc\/connection.h rpc\/rpc.h rpc\/marshall.h rpc\/method_thread.h\\$/;"	m
hfiles2	./GNUmakefile	/^hfiles2=yfs_client.h extent_client.h extent_protocol.h extent_server.h$/;"	m
hfiles3	./GNUmakefile	/^hfiles3=lock_client_cache.h lock_server_cache.h handle.h tprintf.h$/;"	m
hfiles4	./GNUmakefile	/^hfiles4=log.h rsm.h rsm_protocol.h config.h paxos.h paxos_protocol.h rsm_state_transfer.h rsmtest_client.h tprintf.h$/;"	m
hfiles5	./GNUmakefile	/^hfiles5=rsm_state_transfer.h rsm_client.h$/;"	m
highfds_	./rpc/pollmgr.h	/^		int highfds_;$/;"	m	class:SelectAIO
hinfo	./handle.h	/^struct hinfo {$/;"	s
hmap	./handle.h	/^  std::map<std::string, struct hinfo *> hmap;$/;"	m	class:handle_mgr
hostname	./lock_client_cache.h	/^  std::string hostname;$/;"	m	class:lock_client_cache
huge	./test-lab-3-b.c	/^char huge[65536*2+1];$/;"	v
id	./fuse.cc	/^int id() { $/;"	f
id	./lock_client_cache.h	/^  std::string id;$/;"	m	class:lock_client_cache
id	./rpc/rpc.h	/^		unsigned int id() { return clt_nonce_; }$/;"	f	class:rpcc
incref	./rpc/connection.cc	/^connection::incref()$/;"	f	class:connection
ind	./rpc/marshall.h	/^		int ind() { return _ind;}$/;"	f	class:unmarshall
instance	./paxos.h	/^  unsigned instance() { return instance_h; }$/;"	f	class:acceptor
instance	./paxos_protocol.h	/^    unsigned instance;$/;"	m	struct:paxos_protocol::acceptarg
instance	./paxos_protocol.h	/^    unsigned instance;$/;"	m	struct:paxos_protocol::decidearg
instance	./paxos_protocol.h	/^    unsigned instance;$/;"	m	struct:paxos_protocol::preparearg
instance	./rpc/pollmgr.cc	/^PollMgr *PollMgr::instance = NULL;$/;"	m	class:PollMgr	file:
instance	./rpc/pollmgr.h	/^		static PollMgr *instance;$/;"	m	class:PollMgr
instance_h	./paxos.h	/^  unsigned instance_h;	\/\/ number of the highest instance we have decided$/;"	m	class:acceptor
insync	./rsm.h	/^  bool insync; $/;"	m	class:rsm
intret	./rpc/rpc.h	/^			int intret;$/;"	m	struct:rpcc::caller
inum	./yfs_client.h	/^    yfs_client::inum inum;$/;"	m	struct:yfs_client::dirent
inum	./yfs_client.h	/^  typedef unsigned long long inum;$/;"	t	class:yfs_client
inviewchange	./rsm.h	/^  bool inviewchange;$/;"	m	class:rsm
invoke	./rsm.cc	/^rsm::invoke(int proc, viewstamp vs, std::string req, int &dummy)$/;"	f	class:rsm
invoke	./rsm_protocol.h	/^    invoke = 0x10001,$/;"	e	enum:rsm_protocol::rpc_numbers
invoke	./rsm_protocol.h	/^    invoke = 0x9001,$/;"	e	enum:rsm_client_protocol::rpc_numbers
invoke_mutex	./rsm.h	/^  pthread_mutex_t invoke_mutex;$/;"	m	class:rsm
is_watched	./rpc/pollmgr.cc	/^EPollAIO::is_watched(int fd, poll_flag flag)$/;"	f	class:EPollAIO
is_watched	./rpc/pollmgr.cc	/^SelectAIO::is_watched(int fd, poll_flag flag)$/;"	f	class:SelectAIO
isamember	./paxos.cc	/^bool isamember(std::string m, const std::vector<std::string> &nodes)$/;"	f
isattrcached	./extent_client.h	/^     bool isattrcached;$/;"	m	struct:extent_client::extent_cachevalue
iscontentcached	./extent_client.h	/^     bool iscontentcached;$/;"	m	struct:extent_client::extent_cachevalue
isdead	./rpc/connection.cc	/^connection::isdead()$/;"	f	class:connection
isdir	./yfs_client.cc	/^yfs_client::isdir(inum inum)$/;"	f	class:yfs_client
isdirty	./extent_client.h	/^     bool isdirty;   $/;"	m	struct:extent_client::extent_cachevalue
isfile	./yfs_client.cc	/^yfs_client::isfile(inum inum)$/;"	f	class:yfs_client
islossy	./rpc/rpc.h	/^                int islossy() { return lossytest_ > 0; }$/;"	f	class:rpcc
ismember	./config.cc	/^config::ismember(std::string m, unsigned vid)$/;"	f	class:config
isrunning	./paxos.cc	/^proposer::isrunning()$/;"	f	class:proposer
isvalid	./rpc/rpc.h	/^                    bool isvalid() { return xid != -1; }$/;"	f	struct:rpcc::request
job_t	./rpc/thr_pool.h	/^		struct job_t {$/;"	s	class:ThrPool
jobq_	./rpc/thr_pool.h	/^		fifo<job_t> jobq_;$/;"	m	class:ThrPool
join	./rsm.cc	/^rsm::join(std::string m) {$/;"	f	class:rsm
joinreq	./rsm.cc	/^rsm::joinreq(std::string m, viewstamp last, rsm_protocol::joinres &r)$/;"	f	class:rsm
joinreq	./rsm_protocol.h	/^    joinreq,$/;"	e	enum:rsm_protocol::rpc_numbers
joinres	./rsm_protocol.h	/^  struct joinres {$/;"	s	class:rsm_protocol
jsl_log	./rpc/jsl_log.h	14;"	d
jsl_set_debug	./rpc/jsl_log.cc	/^jsl_set_debug(int level) {$/;"	f
kfree	./lock_server.h	/^const int kfree = 0;$/;"	v
killprocess	./rsm_tester.pl	/^sub killprocess {$/;"	s
klocked	./lock_server.h	/^const int klocked = 1;$/;"	v
l	./paxos.h	/^  log *l;$/;"	m	class:acceptor
l	./paxos.h	/^  log *l;$/;"	m	class:proposer
labdir	./GNUmakefile	/^labdir=$(shell basename $(PWD))$/;"	m
last	./rsm_protocol.h	/^    viewstamp last;$/;"	m	struct:rsm_protocol::transferres
last_myvs	./rsm.h	/^  viewstamp last_myvs;   \/\/ Viewstamp of the last executed request$/;"	m	class:rsm
lc	./lock_demo.cc	/^lock_client *lc;$/;"	v
lc	./lock_tester.cc	/^lock_client_cache **lc = new lock_client_cache * [nt];$/;"	v
lc	./yfs_client.h	/^  lock_client *lc;$/;"	m	class:yfs_client
limited_rand	./yfs_client.cc	/^int limited_rand(int limit)$/;"	f
listener_	./rpc/rpc.h	/^	tcpsconn* listener_;$/;"	m	class:rpcs
livecheck	./test-lab-2-a.pl	/^sub livecheck {$/;"	s
livecheck	./test-lab-3-a.pl	/^sub livecheck {$/;"	s
lock_cache	./lock_server_cache.h	/^  struct lock_cache {$/;"	s	class:lock_server_cache
lock_cache_mutex	./lock_server_cache.h	/^  std::mutex lock_cache_mutex;$/;"	m	class:lock_server_cache
lock_client	./lock_client.cc	/^lock_client::lock_client(std::string dst)$/;"	f	class:lock_client
lock_client	./lock_client.h	/^class lock_client {$/;"	c
lock_client_cache	./lock_client_cache.cc	/^lock_client_cache::lock_client_cache(std::string xdst, $/;"	f	class:lock_client_cache
lock_client_cache	./lock_client_cache.h	/^class lock_client_cache : public lock_client {$/;"	c
lock_client_cache_h	./lock_client_cache.h	5;"	d
lock_client_h	./lock_client.h	4;"	d
lock_demo	./GNUmakefile	/^lock_demo=lock_demo.cc lock_client.cc$/;"	m
lock_protocol	./lock_protocol.h	/^class lock_protocol {$/;"	c
lock_protocol_h	./lock_protocol.h	4;"	d
lock_release_user	./lock_client_cache.h	/^class lock_release_user {$/;"	c
lock_server	./GNUmakefile	/^lock_server=lock_server.cc lock_smain.cc$/;"	m
lock_server	./lock_server.cc	/^lock_server::lock_server():$/;"	f	class:lock_server
lock_server	./lock_server.h	/^class lock_server {$/;"	c
lock_server_cache	./lock_server_cache.cc	/^lock_server_cache::lock_server_cache():lock_server(){$/;"	f	class:lock_server_cache
lock_server_cache	./lock_server_cache.h	/^class lock_server_cache :lock_server{$/;"	c
lock_server_cache_h	./lock_server_cache.h	2;"	d
lock_server_h	./lock_server.h	5;"	d
lock_state	./lock_server_cache.h	/^  enum lock_state {$/;"	g	class:lock_server_cache
lock_table_	./lock_server.h	/^  std::map<lock_protocol::lockid_t,  lock_protocol::status> lock_table_;$/;"	m	class:lock_server
lock_tester	./GNUmakefile	/^lock_tester=lock_tester.cc lock_client.cc$/;"	m
lockcv	./lock_client_cache.h	/^  std::condition_variable lockcv;$/;"	m	struct:CacheLock
locked	./lock_server.h	/^  bool locked = false;$/;"	m	class:lock_server
lockid_t	./lock_protocol.h	/^  typedef unsigned long long lockid_t;$/;"	t	class:lock_protocol
log	./log.cc	/^log::log(acceptor *_acc, std::string _me)$/;"	f	class:log
log	./log.h	/^class log {$/;"	c
log	./rsm_protocol.h	/^    std::string log;$/;"	m	struct:rsm_protocol::joinres
log_h	./log.h	2;"	d
logaccept	./log.cc	/^log::logaccept(prop_t n, std::string v)$/;"	f	class:log
loginstance	./log.cc	/^log::loginstance(unsigned instance, std::string v)$/;"	f	class:log
logprop	./log.cc	/^log::logprop(prop_t n_h)$/;"	f	class:log
logread	./log.cc	/^log::logread(void)$/;"	f	class:log
lookup	./yfs_client.cc	/^int yfs_client::lookup(inum p_inum, const char *name, inum &c_inum) {$/;"	f	class:yfs_client
lossy	./rpc/connection.h	/^	int lossy;$/;"	m	struct:bundle
lossy_	./rpc/connection.h	/^		const int lossy_;$/;"	m	class:connection
lossy_	./rpc/connection.h	/^		int lossy_;$/;"	m	class:tcpsconn
lossy_test	./rpc/rpctest.cc	/^lossy_test()$/;"	f
lossytest_	./rpc/rpc.h	/^		int lossytest_;$/;"	m	class:rpcc
lossytest_	./rpc/rpc.h	/^	int lossytest_; $/;"	m	class:rpcs
lu	./lock_client_cache.h	/^  class lock_release_user *lu;$/;"	m	class:lock_client_cache	typeref:class:lock_client_cache::lock_release_user
lu	./yfs_client.h	/^  mylock_release_user *lu;$/;"	m	class:yfs_client
m	./extent_server.h	/^  std::mutex m;$/;"	m	class:extent_server
m	./handle.h	/^  std::string m;$/;"	m	struct:hinfo
m	./lock_client_cache.h	/^  std::mutex m;$/;"	m	struct:CacheLock
m	./paxos_protocol.h	/^  std::string m;$/;"	m	struct:prop_t
m	./rpc/method_thread.h	/^				void (C::*m)(A1 a1, A2 a2);$/;"	m	class:__anon3::XXX
m	./rpc/rpc.h	/^			pthread_mutex_t m;$/;"	m	struct:rpcc::caller
m_	./rpc/connection.h	/^		pthread_mutex_t m_;$/;"	m	class:connection
m_	./rpc/connection.h	/^		pthread_mutex_t m_;$/;"	m	class:tcpsconn
m_	./rpc/fifo.h	/^		pthread_mutex_t m_;$/;"	m	class:fifo
m_	./rpc/pollmgr.h	/^		pthread_mutex_t m_;$/;"	m	class:PollMgr
m_	./rpc/pollmgr.h	/^		pthread_mutex_t m_;$/;"	m	class:SelectAIO
m_	./rpc/rpc.h	/^		pthread_mutex_t m_; \/\/ protect insert\/delete to calls[]$/;"	m	class:rpcc
m_	./rpc/slock.h	/^		pthread_mutex_t *m_;$/;"	m	struct:ScopedLock
main	./extent_smain.cc	/^main(int argc, char *argv[])$/;"	f
main	./fuse.cc	/^main(int argc, char *argv[])$/;"	f
main	./lock_demo.cc	/^main(int argc, char *argv[])$/;"	f
main	./lock_smain.cc	/^main(int argc, char *argv[])$/;"	f
main	./lock_tester.cc	/^main(int argc, char *argv[])$/;"	f
main	./rpc/rpctest.cc	/^main(int argc, char *argv[])$/;"	f
main	./rsm_tester.cc	/^main(int argc, char *argv[])$/;"	f
main	./test-lab-3-b.c	/^main(int argc, char *argv[])$/;"	f
main	./test-lab-3-c.c	/^main(int argc, char *argv[])$/;"	f
majority	./paxos.cc	/^proposer::majority(const std::vector<std::string> &l1, $/;"	f	class:proposer
make_sockaddr	./rpc/rpc.cc	/^make_sockaddr(const char *host, const char *port, struct sockaddr_in *dst){$/;"	f
make_sockaddr	./rpc/rpc.cc	/^make_sockaddr(const char *hostandport, struct sockaddr_in *dst){$/;"	f
marshall	./rpc/marshall.h	/^		marshall() {$/;"	f	class:marshall
marshall	./rpc/marshall.h	/^class marshall {$/;"	c
marshall_h	./rpc/marshall.h	2;"	d
max_	./rpc/fifo.h	/^		unsigned int max_; \/\/maximum capacity of the queue, block enq threads if exceeds this limit$/;"	m	class:fifo
me	./config.h	/^  std::string me;$/;"	m	class:config
me	./paxos.h	/^  std::string me;$/;"	m	class:acceptor
me	./paxos.h	/^  std::string me;$/;"	m	class:proposer
members	./config.cc	/^config::members(std::string value)$/;"	f	class:config
members	./rsm_protocol.h	/^    members,$/;"	e	enum:rsm_client_protocol::rpc_numbers
mems	./config.h	/^  std::vector<std::string> mems;$/;"	m	class:config
method_thread	./rpc/method_thread.h	/^method_thread(C *o, bool detach, void (C::*m)())$/;"	f
method_thread	./rpc/method_thread.h	/^method_thread(C *o, bool detach, void (C::*m)(A), A a)$/;"	f
method_thread	./rpc/method_thread.h	/^method_thread(C *o, bool detach, void (C::*m)(A1 , A2 ), A1 a1, A2 a2)$/;"	f
method_thread	./rpc/method_thread.h	/^method_thread(C *o, bool detach, void (C::*m)(A1 , A2, A3 ), A1 a1, A2 a2, A3 a3)$/;"	f
method_thread_child	./rpc/method_thread.h	/^method_thread_child()$/;"	f
method_thread_h	./rpc/method_thread.h	2;"	d
method_thread_parent	./rpc/method_thread.h	/^method_thread_parent(void *(*fn)(void *), void *arg, bool detach)$/;"	f
mgr	./handle.cc	/^handle_mgr mgr;$/;"	v
mgr	./rpc/connection.h	/^	chanmgr *mgr;$/;"	m	struct:bundle
mgr_	./rpc/connection.h	/^		chanmgr *mgr_;$/;"	m	class:connection
mgr_	./rpc/connection.h	/^		chanmgr *mgr_;$/;"	m	class:tcpsconn
min	./fuse.cc	421;"	d	file:
mtime	./extent_protocol.h	/^    unsigned int mtime;$/;"	m	struct:extent_protocol::attr
mtime	./yfs_client.h	/^    unsigned long mtime;$/;"	m	struct:yfs_client::dirinfo
mtime	./yfs_client.h	/^    unsigned long mtime;$/;"	m	struct:yfs_client::fileinfo
my_n	./paxos.h	/^  prop_t my_n;		\/\/ number of the last proposal used in this instance$/;"	m	class:proposer
myaddr	./config.h	/^  std::string myaddr() { return me; };$/;"	f	class:config
mydie	./rsm_tester.pl	/^sub mydie {$/;"	s
myid	./fuse.cc	/^int myid;$/;"	v
mylock_release_user	./yfs_client.cc	/^    mylock_release_user(extent_client *_ec) {$/;"	f	class:mylock_release_user
mylock_release_user	./yfs_client.cc	/^class mylock_release_user:public lock_release_user {$/;"	c	file:
myvid	./config.h	/^  unsigned myvid;$/;"	m	class:config
myvs	./rsm.h	/^  viewstamp myvs;$/;"	m	class:rsm
n	./paxos_protocol.h	/^    prop_t n;$/;"	m	struct:paxos_protocol::acceptarg
n	./paxos_protocol.h	/^    prop_t n;$/;"	m	struct:paxos_protocol::preparearg
n	./paxos_protocol.h	/^  unsigned n;$/;"	m	struct:prop_t
n2i	./yfs_client.cc	/^yfs_client::n2i(std::string n)$/;"	f	class:yfs_client
n_a	./paxos.h	/^  prop_t n_a;		\/\/ number of highest proposal accepted$/;"	m	class:acceptor
n_a	./paxos_protocol.h	/^    prop_t n_a;$/;"	m	struct:paxos_protocol::prepareres
n_h	./paxos.h	/^  prop_t n_h;		\/\/ number of the highest proposal seen in a prepare$/;"	m	class:acceptor
nacquire	./lock_server.h	/^  int nacquire;  $/;"	m	class:lock_server
nacquire	./lock_server_cache.h	/^  int nacquire;$/;"	m	class:lock_server_cache
name	./log.h	/^  std::string name;$/;"	m	class:log
name	./yfs_client.h	/^    std::string name;$/;"	m	struct:yfs_client::dirent
net_repair	./rsm_protocol.h	/^    net_repair = 0x12001,$/;"	e	enum:rsm_test_protocol::rpc_numbers
net_repair	./rsmtest_client.cc	/^rsmtest_client::net_repair(int heal)$/;"	f	class:rsmtest_client
net_repair_wo	./rsm.cc	/^rsm::net_repair_wo(bool heal)$/;"	f	class:rsm
new_inum	./yfs_client.cc	/^yfs_client::inum yfs_client::new_inum(bool isfile)$/;"	f	class:yfs_client
non_empty_c_	./rpc/fifo.h	/^		pthread_cond_t non_empty_c_; \/\/ q went non-empty$/;"	m	class:fifo
nonce_	./rpc/rpc.h	/^	unsigned int nonce_;$/;"	m	class:rpcs
nt	./lock_tester.cc	/^int nt = 4; \/\/XXX: lab1's rpc handlers are blocking. Since rpcs uses a thread pool of 10 threads, we cannot test more than 10 blocking rpc.$/;"	v
nthreads_	./rpc/thr_pool.h	/^		int nthreads_;$/;"	m	class:ThrPool
o	./rpc/method_thread.h	/^				C *o;$/;"	m	class:__anon3::XXX
ok	./rpc/marshall.h	/^		bool ok() { return _ok; }$/;"	f	class:unmarshall
okdone	./rpc/rpc.cc	/^unmarshall::okdone()$/;"	f	class:unmarshall
oldinstance	./paxos_protocol.h	/^    bool oldinstance;$/;"	m	struct:paxos_protocol::prepareres
oldsrv_failure	./rpc/rpc.h	/^		static const int oldsrv_failure = -5;$/;"	m	class:rpc_const
oops	./test-lab-3-a.pl	/^sub oops {$/;"	s
oops1	./test-lab-3-a.pl	/^sub oops1 {$/;"	s
operator !=	./rsm_protocol.h	/^inline bool operator!=(viewstamp a, viewstamp b) {$/;"	f
operator <	./rpc/rpc.cc	/^bool operator<(const sockaddr_in &a, const sockaddr_in &b){$/;"	f
operator <<	./extent_protocol.h	/^operator<<(marshall &m, extent_protocol::attr a)$/;"	f
operator <<	./paxos_protocol.h	/^operator<<(marshall &m, paxos_protocol::acceptarg a)$/;"	f
operator <<	./paxos_protocol.h	/^operator<<(marshall &m, paxos_protocol::decidearg a)$/;"	f
operator <<	./paxos_protocol.h	/^operator<<(marshall &m, paxos_protocol::preparearg a)$/;"	f
operator <<	./paxos_protocol.h	/^operator<<(marshall &m, paxos_protocol::prepareres r)$/;"	f
operator <<	./paxos_protocol.h	/^operator<<(marshall &m, prop_t a)$/;"	f
operator <<	./rpc/marshall.h	/^operator<<(marshall &m, const std::map<A,B> &d) {$/;"	f
operator <<	./rpc/marshall.h	/^operator<<(marshall &m, std::vector<C> v)$/;"	f
operator <<	./rpc/rpc.cc	/^operator<<(marshall &m, bool x)$/;"	f
operator <<	./rpc/rpc.cc	/^operator<<(marshall &m, char x)$/;"	f
operator <<	./rpc/rpc.cc	/^operator<<(marshall &m, const std::string &s)$/;"	f
operator <<	./rpc/rpc.cc	/^operator<<(marshall &m, int x)$/;"	f
operator <<	./rpc/rpc.cc	/^operator<<(marshall &m, short x)$/;"	f
operator <<	./rpc/rpc.cc	/^operator<<(marshall &m, unsigned char x)$/;"	f
operator <<	./rpc/rpc.cc	/^operator<<(marshall &m, unsigned int x)$/;"	f
operator <<	./rpc/rpc.cc	/^operator<<(marshall &m, unsigned long long x)$/;"	f
operator <<	./rpc/rpc.cc	/^operator<<(marshall &m, unsigned short x)$/;"	f
operator <<	./rsm_protocol.h	/^inline marshall& operator<<(marshall &m, viewstamp v)$/;"	f
operator <<	./rsm_protocol.h	/^operator<<(marshall &m, rsm_protocol::joinres r)$/;"	f
operator <<	./rsm_protocol.h	/^operator<<(marshall &m, rsm_protocol::transferres r)$/;"	f
operator ==	./rsm_protocol.h	/^inline bool operator==(viewstamp a, viewstamp b) {$/;"	f
operator >	./paxos.cc	/^operator> (const prop_t &a, const prop_t &b)$/;"	f
operator >	./rsm_protocol.h	/^inline bool operator>(viewstamp a, viewstamp b) {$/;"	f
operator >=	./paxos.cc	/^operator>= (const prop_t &a, const prop_t &b)$/;"	f
operator >>	./extent_protocol.h	/^operator>>(unmarshall &u, extent_protocol::attr &a)$/;"	f
operator >>	./paxos_protocol.h	/^operator>>(unmarshall &u, paxos_protocol::acceptarg &a)$/;"	f
operator >>	./paxos_protocol.h	/^operator>>(unmarshall &u, paxos_protocol::decidearg &a)$/;"	f
operator >>	./paxos_protocol.h	/^operator>>(unmarshall &u, paxos_protocol::preparearg &a)$/;"	f
operator >>	./paxos_protocol.h	/^operator>>(unmarshall &u, paxos_protocol::prepareres &r)$/;"	f
operator >>	./paxos_protocol.h	/^operator>>(unmarshall &u, prop_t &a)$/;"	f
operator >>	./rpc/marshall.h	/^operator>>(unmarshall &u, std::map<A,B> &d) {$/;"	f
operator >>	./rpc/marshall.h	/^operator>>(unmarshall &u, std::vector<C> &v)$/;"	f
operator >>	./rpc/rpc.cc	/^operator>>(unmarshall &u, bool &x)$/;"	f
operator >>	./rpc/rpc.cc	/^operator>>(unmarshall &u, char &x)$/;"	f
operator >>	./rpc/rpc.cc	/^operator>>(unmarshall &u, int &x)$/;"	f
operator >>	./rpc/rpc.cc	/^operator>>(unmarshall &u, short &x)$/;"	f
operator >>	./rpc/rpc.cc	/^operator>>(unmarshall &u, std::string &s)$/;"	f
operator >>	./rpc/rpc.cc	/^operator>>(unmarshall &u, unsigned char &x)$/;"	f
operator >>	./rpc/rpc.cc	/^operator>>(unmarshall &u, unsigned int &x)$/;"	f
operator >>	./rpc/rpc.cc	/^operator>>(unmarshall &u, unsigned long long &x)$/;"	f
operator >>	./rpc/rpc.cc	/^operator>>(unmarshall &u, unsigned short &x)$/;"	f
operator >>	./rsm_protocol.h	/^inline unmarshall& operator>>(unmarshall &u, viewstamp &v) {$/;"	f
operator >>	./rsm_protocol.h	/^operator>>(unmarshall &u, rsm_protocol::joinres &r)$/;"	f
operator >>	./rsm_protocol.h	/^operator>>(unmarshall &u, rsm_protocol::transferres &r)$/;"	f
ownerid	./lock_server_cache.h	/^     std::string ownerid;$/;"	m	struct:lock_server_cache::lock_cache
p	./fuse.cc	/^    char *p;$/;"	m	struct:dirbuf	file:
pack	./rpc/rpc.cc	/^marshall::pack(int x)$/;"	f	class:marshall
pack_reply_header	./rpc/marshall.h	/^		void pack_reply_header(const reply_header &h) {$/;"	f	class:marshall
pack_req_header	./rpc/marshall.h	/^		void pack_req_header(const req_header &h) {$/;"	f	class:marshall
partition1	./rsm.cc	/^rsm::partition1()$/;"	f	class:rsm
partitioned	./rsm.h	/^  bool partitioned;$/;"	m	class:rsm
paxos_change	./paxos.h	/^class paxos_change {$/;"	c
paxos_commit	./config.cc	/^config::paxos_commit(unsigned instance, std::string value)$/;"	f	class:config
paxos_h	./paxos.h	2;"	d
paxos_log	./rsm_tester.pl	/^sub paxos_log {$/;"	s
paxos_protocol	./paxos_protocol.h	/^class paxos_protocol {$/;"	c
paxos_protocol_h	./paxos_protocol.h	2;"	d
pending_change_	./rpc/pollmgr.h	/^		bool pending_change_;$/;"	m	class:PollMgr
pipe_	./rpc/connection.h	/^		int pipe_[2];$/;"	m	class:tcpsconn
pipefd_	./rpc/pollmgr.h	/^		int pipefd_[2];$/;"	m	class:SelectAIO
poll_flag	./rpc/pollmgr.h	/^} poll_flag;$/;"	t	typeref:enum:__anon6
poll_flag_to_event	./rpc/pollmgr.cc	/^int poll_flag_to_event(poll_flag flag)$/;"	f	file:
pollfd_	./rpc/pollmgr.h	/^		int pollfd_;$/;"	m	class:EPollAIO
pollmgr_h	./rpc/pollmgr.h	2;"	d
pollmgr_is_initialized	./rpc/pollmgr.cc	/^static pthread_once_t pollmgr_is_initialized = PTHREAD_ONCE_INIT;$/;"	v	file:
port	./rpc/connection.h	/^                inline int port() { return port_; }$/;"	f	class:tcpsconn
port	./rpc/rpc.h	/^        inline int port() { return listener_->port(); }$/;"	f	class:rpcs
port	./rpc/rpctest.cc	/^int port;$/;"	v
port_	./rpc/connection.h	/^                int port_;$/;"	m	class:tcpsconn
port_	./rpc/rpc.h	/^	int port_;$/;"	m	class:rpcs
prepare	./paxos.cc	/^proposer::prepare(unsigned instance, std::vector<std::string> &accepts, $/;"	f	class:proposer
preparearg	./paxos_protocol.h	/^  struct preparearg {$/;"	s	class:paxos_protocol
preparereq	./paxos_protocol.h	/^    preparereq = 0x11001,$/;"	e	enum:paxos_protocol::rpc_numbers
prepareres	./paxos_protocol.h	/^  struct prepareres {$/;"	s	class:paxos_protocol
primary	./rsm.h	/^  std::string primary;$/;"	m	class:rsm
print_config	./rsm_tester.pl	/^sub print_config {$/;"	s
print_members	./paxos.cc	/^print_members(const std::vector<std::string> &nodes)$/;"	f
pro	./config.h	/^  proposer *pro;$/;"	m	class:config
proc	./rpc/marshall.h	/^	int proc;$/;"	m	struct:req_header
process_accept	./rpc/connection.cc	/^tcpsconn::process_accept()$/;"	f	class:tcpsconn
procs	./rsm.h	/^  std::map<int, handler *> procs;$/;"	m	class:rsm
procs_	./rpc/rpc.h	/^	std::map<int, handler *> procs_;$/;"	m	class:rpcs
procs_m_	./rpc/rpc.h	/^	pthread_mutex_t procs_m_; \/\/ protect insert\/delete to procs[]$/;"	m	class:rpcs
prop_t	./paxos_protocol.h	/^struct prop_t {$/;"	s
proposer	./paxos.cc	/^proposer::proposer(class paxos_change *_cfg, class acceptor *_acceptor, $/;"	f	class:proposer
proposer	./paxos.h	/^class proposer {$/;"	c
put	./extent_client.cc	/^extent_client::put(extent_protocol::extentid_t eid, std::string buf)$/;"	f	class:extent_client
put	./extent_protocol.h	/^    put = 0x6001,$/;"	e	enum:extent_protocol::rpc_numbers
put	./extent_server.cc	/^int extent_server::put(extent_protocol::extentid_t id, std::string buf, int &)$/;"	f	class:extent_server
put	./yfs_client.cc	/^int yfs_client::put(inum inum, std::string content){$/;"	f	class:yfs_client
pxs	./log.h	/^  acceptor *pxs;$/;"	m	class:log
pxs	./paxos.h	/^  rpcs *pxs;$/;"	m	class:acceptor
pxs_mutex	./paxos.h	/^  pthread_mutex_t pxs_mutex;$/;"	m	class:acceptor
pxs_mutex	./paxos.h	/^  pthread_mutex_t pxs_mutex;$/;"	m	class:proposer
pxsrpc	./config.h	/^  rpcs *pxsrpc;$/;"	m	class:config
q_	./rpc/fifo.h	/^		std::list<T> q_;$/;"	m	class:fifo
randports	./rsm_tester.pl	/^sub randports {$/;"	s
rawbyte	./rpc/rpc.cc	/^marshall::rawbyte(unsigned char x)$/;"	f	class:marshall
rawbyte	./rpc/rpc.cc	/^unmarshall::rawbyte()$/;"	f	class:unmarshall
rawbytes	./rpc/rpc.cc	/^marshall::rawbytes(const char *p, int n)$/;"	f	class:marshall
rawbytes	./rpc/rpc.cc	/^unmarshall::rawbytes(std::string &ss, unsigned int n)$/;"	f	class:unmarshall
reachable_	./rpc/rpc.h	/^		bool reachable_;$/;"	m	class:rpcc
reachable_	./rpc/rpc.h	/^	bool reachable_;$/;"	m	class:rpcs
read	./yfs_client.cc	/^yfs_client::read(inum inum, std::string &buf, off_t offset, size_t nbytes)$/;"	f	class:yfs_client
read_cb	./rpc/connection.cc	/^connection::read_cb(int s)$/;"	f	class:connection
readpdu	./rpc/connection.cc	/^connection::readpdu()$/;"	f	class:connection
ready_	./rpc/pollmgr.h	/^		struct epoll_event ready_[MAX_POLL_FDS];$/;"	m	class:EPollAIO	typeref:struct:EPollAIO::epoll_event
reap	./test-lab-3-b.c	/^reap (int pid)$/;"	f
reap	./test-lab-3-c.c	/^reap (int pid)$/;"	f
reconstruct	./config.cc	/^config::reconstruct()$/;"	f	class:config
recovery	./rsm.cc	/^rsm::recovery()$/;"	f	class:rsm
recovery_cond	./rsm.h	/^  pthread_cond_t recovery_cond;$/;"	m	class:rsm
recoverythread	./rsm.cc	/^recoverythread(void *x)$/;"	f	file:
ref	./rpc/connection.cc	/^connection::ref()$/;"	f	class:connection
ref_m_	./rpc/connection.h	/^		pthread_mutex_t ref_m_;$/;"	m	class:connection
refcnt	./handle.h	/^  int refcnt;$/;"	m	struct:hinfo
refno_	./rpc/connection.h	/^		int refno_;$/;"	m	class:connection
reg	./rpc/rpc.h	/^rpcs::reg(unsigned int proc, S*sob, int (S::*meth)(const A1 a1, R & r))$/;"	f	class:rpcs
reg	./rpc/rpc.h	/^rpcs::reg(unsigned int proc, S*sob, int (S::*meth)(const A1 a1, const A2 a2, $/;"	f	class:rpcs
reg1	./rpc/rpc.cc	/^rpcs::reg1(unsigned int proc, handler *h)$/;"	f	class:rpcs
release	./lock_client.cc	/^lock_client::release(lock_protocol::lockid_t lid)$/;"	f	class:lock_client
release	./lock_client_cache.cc	/^lock_client_cache::release(lock_protocol::lockid_t lid)$/;"	f	class:lock_client_cache
release	./lock_protocol.h	/^    release,$/;"	e	enum:lock_protocol::rpc_numbers
release	./lock_server.cc	/^lock_server::release(int clt,lock_protocol::lockid_t lid, int &r)$/;"	f	class:lock_server
release	./lock_server_cache.cc	/^lock_server_cache::release(lock_protocol::lockid_t lid, std::string id, $/;"	f	class:lock_server_cache
remove	./extent_client.cc	/^extent_client::remove(extent_protocol::extentid_t eid)$/;"	f	class:extent_client
remove	./extent_protocol.h	/^    remove$/;"	e	enum:extent_protocol::rpc_numbers
remove	./extent_server.cc	/^int extent_server::remove(extent_protocol::extentid_t id, int &)$/;"	f	class:extent_server
remove	./yfs_client.cc	/^yfs_client::remove(inum num) {$/;"	f	class:yfs_client
remove_wo	./config.cc	/^config::remove_wo(std::string m)$/;"	f	class:config
reply_buf_limited	./fuse.cc	/^int reply_buf_limited(fuse_req_t req, const char *buf, size_t bufsize,$/;"	f
reply_header	./rpc/marshall.h	/^	reply_header(int x=0, int r=0): xid(x), ret(r) {}$/;"	f	struct:reply_header
reply_header	./rpc/marshall.h	/^struct reply_header {$/;"	s
reply_t	./rpc/rpc.h	/^		reply_t (unsigned int _xid) {$/;"	f	struct:rpcs::reply_t
reply_t	./rpc/rpc.h	/^	struct reply_t {$/;"	s	class:rpcs
reply_window_	./rpc/rpc.h	/^	std::map<unsigned int, std::list<reply_t> > reply_window_;$/;"	m	class:rpcs
reply_window_m_	./rpc/rpc.h	/^	pthread_mutex_t reply_window_m_; \/\/ protect reply window et al$/;"	m	class:rpcs
req_header	./rpc/marshall.h	/^	req_header(int x=0, int p=0, int c = 0, int s = 0, int xi = 0):$/;"	f	struct:req_header
req_header	./rpc/marshall.h	/^struct req_header {$/;"	s
request	./rpc/rpc.h	/^                    request() { clear(); }$/;"	f	struct:rpcc::request
request	./rpc/rpc.h	/^                struct request {$/;"	s	class:rpcc
restore	./config.cc	/^config::restore(std::string s)$/;"	f	class:config
restore	./log.cc	/^log::restore(std::string s)$/;"	f	class:log
ret	./rpc/marshall.h	/^	int ret;$/;"	m	struct:reply_header
retrans_	./rpc/rpc.h	/^		bool retrans_;$/;"	m	class:rpcc
retry	./lock_protocol.h	/^    retry = 0x8002$/;"	e	enum:rlock_protocol::rpc_numbers
retry_handler	./lock_client_cache.cc	/^lock_client_cache::retry_handler(lock_protocol::lockid_t lid, $/;"	f	class:lock_client_cache
retrycv	./lock_server_cache.h	/^  std::condition_variable retrycv;$/;"	m	class:lock_server_cache
retryingid	./lock_server_cache.h	/^     std::string retryingid;$/;"	m	struct:lock_server_cache::lock_cache
retryqueue	./lock_client_cache.h	/^  std::queue<lock_protocol::lockid_t> retryqueue;$/;"	m	class:lock_client_cache
retryqueue	./lock_server_cache.h	/^  std::queue<std::pair<std::string,lock_protocol::lockid_t>> retryqueue;$/;"	m	class:lock_server_cache
retryqueuecv	./lock_client_cache.h	/^  std::condition_variable retryqueuecv;$/;"	m	class:lock_client_cache
retryqueuemutex	./lock_client_cache.h	/^  std::mutex retryqueuemutex;$/;"	m	class:lock_client_cache
retryqueuemutex	./lock_server_cache.h	/^  std::mutex retryqueuemutex;$/;"	m	class:lock_server_cache
retrythread	./lock_client_cache.cc	/^void lock_client_cache::retrythread() {$/;"	f	class:lock_client_cache
retrythread	./lock_server_cache.cc	/^void lock_server_cache::retrythread() {$/;"	f	class:lock_server_cache
revoke	./lock_protocol.h	/^    revoke = 0x8001,$/;"	e	enum:rlock_protocol::rpc_numbers
revoke_handler	./lock_client_cache.cc	/^lock_client_cache::revoke_handler(lock_protocol::lockid_t lid, $/;"	f	class:lock_client_cache
revokecv	./lock_client_cache.h	/^  std::condition_variable revokecv;$/;"	m	struct:CacheLock
revokecv	./lock_server_cache.h	/^  std::condition_variable revokecv;$/;"	m	class:lock_server_cache
revokelist	./lock_server_cache.h	/^  std::list<std::pair<std::string,lock_protocol::lockid_t>> revokelist;$/;"	m	class:lock_server_cache
revokelistmutex	./lock_server_cache.h	/^  std::mutex revokelistmutex;$/;"	m	class:lock_server_cache
revokequeue	./lock_client_cache.h	/^  std::queue<lock_protocol::lockid_t> revokequeue;$/;"	m	class:lock_client_cache
revokequeuecv	./lock_client_cache.h	/^  std::condition_variable revokequeuecv;$/;"	m	class:lock_client_cache
revokequeuemutex	./lock_client_cache.h	/^  std::mutex revokequeuemutex;$/;"	m	class:lock_client_cache
revokethread	./lock_client_cache.cc	/^void lock_client_cache::revokethread() {$/;"	f	class:lock_client_cache
revokethread	./lock_server_cache.cc	/^void lock_server_cache::revokethread() {$/;"	f	class:lock_server_cache
rfds_	./rpc/pollmgr.h	/^		fd_set rfds_;$/;"	m	class:SelectAIO
rk	./lock_client_cache.h	/^  std::thread rk;$/;"	m	class:lock_client_cache
rk	./lock_server_cache.h	/^  std::thread rk;$/;"	m	class:lock_server_cache
rlock_port	./lock_client_cache.h	/^  int rlock_port;$/;"	m	class:lock_client_cache
rlock_protocol	./lock_protocol.h	/^class rlock_protocol {$/;"	c
rpc_checksum_t	./rpc/marshall.h	/^typedef uint64_t rpc_checksum_t;$/;"	t
rpc_const	./rpc/rpc.h	/^class rpc_const {$/;"	c
rpc_h	./rpc/rpc.h	2;"	d
rpc_numbers	./extent_protocol.h	/^  enum rpc_numbers {$/;"	g	class:extent_protocol
rpc_numbers	./lock_protocol.h	/^  enum rpc_numbers {$/;"	g	class:lock_protocol
rpc_numbers	./lock_protocol.h	/^  enum rpc_numbers {$/;"	g	class:rlock_protocol
rpc_numbers	./paxos_protocol.h	/^  enum rpc_numbers {$/;"	g	class:paxos_protocol
rpc_numbers	./rsm_protocol.h	/^  enum rpc_numbers {$/;"	g	class:rsm_client_protocol
rpc_numbers	./rsm_protocol.h	/^  enum rpc_numbers {$/;"	g	class:rsm_protocol
rpc_numbers	./rsm_protocol.h	/^  enum rpc_numbers {$/;"	g	class:rsm_test_protocol
rpc_sz_t	./rpc/marshall.h	/^typedef int rpc_sz_t;$/;"	t
rpcbind	./rpc/rpc.cc	/^rpcs::rpcbind(int a, int &r)$/;"	f	class:rpcs
rpcc	./rpc/rpc.cc	/^rpcc::rpcc(sockaddr_in d, bool retrans) : $/;"	f	class:rpcc
rpcc	./rpc/rpc.h	/^class rpcc : public chanmgr {$/;"	c
rpclib	./GNUmakefile	/^rpclib=rpc\/rpc.cc rpc\/connection.cc rpc\/pollmgr.cc rpc\/thr_pool.cc rpc\/jsl_log.cc gettime.cc$/;"	m
rpcs	./rpc/rpc.cc	/^  rpcs::rpcs(unsigned int p1, int count)$/;"	f	class:rpcs
rpcs	./rpc/rpc.h	/^class rpcs : public chanmgr {$/;"	c
rpcstate_t	./rpc/rpc.h	/^	} rpcstate_t;$/;"	t	class:rpcs	typeref:enum:rpcs::__anon4
rpctest	./GNUmakefile	/^rpc\/rpctest=rpc\/rpctest.cc$/;"	m
rpdu_	./rpc/connection.h	/^		charbuf rpdu_;$/;"	m	class:connection
rsm	./rsm.cc	/^rsm::rsm(std::string _first, std::string _me) $/;"	f	class:rsm
rsm	./rsm.h	/^class rsm : public config_view_change {$/;"	c
rsm_client_protocol	./rsm_protocol.h	/^class rsm_client_protocol {$/;"	c
rsm_files	./GNUmakefile	/^rsm_files = rsm.cc paxos.cc config.cc log.cc handle.cc$/;"	m
rsm_h	./rsm.h	4;"	d
rsm_mutex	./rsm.h	/^  pthread_mutex_t rsm_mutex;$/;"	m	class:rsm
rsm_protocol	./rsm_protocol.h	/^class rsm_protocol {$/;"	c
rsm_protocol_h	./rsm_protocol.h	2;"	d
rsm_state_transfer	./rsm_state_transfer.h	/^class rsm_state_transfer {$/;"	c
rsm_state_transfer_h	./rsm_state_transfer.h	2;"	d
rsm_test_protocol	./rsm_protocol.h	/^class rsm_test_protocol {$/;"	c
rsm_tester	./GNUmakefile	/^rsm_tester=rsm_tester.cc rsmtest_client.cc$/;"	m
rsmrpc	./rsm.h	/^  rpcs *rsmrpc;$/;"	m	class:rsm
rsmtest_client	./rsmtest_client.cc	/^rsmtest_client::rsmtest_client(std::string dst)$/;"	f	class:rsmtest_client
rsmtest_client	./rsmtest_client.h	/^class rsmtest_client {$/;"	c
rsmtest_client_h	./rsmtest_client.h	4;"	d
rt	./lock_client_cache.h	/^  std::thread rt;$/;"	m	class:lock_client_cache
rt	./lock_server_cache.h	/^  std::thread rt;$/;"	m	class:lock_server_cache
run	./paxos.cc	/^proposer::run(int instance, std::vector<std::string> cur_nodes, std::string newv)$/;"	f	class:proposer
safebind	./handle.cc	/^handle::safebind()$/;"	f	class:handle
send	./rpc/connection.cc	/^connection::send(char *b, int sz)$/;"	f	class:connection
send_complete_	./rpc/connection.h	/^		pthread_cond_t send_complete_;$/;"	m	class:connection
send_wait_	./rpc/connection.h	/^		pthread_cond_t send_wait_;$/;"	m	class:connection
seqno	./rsm_protocol.h	/^  unsigned int seqno;$/;"	m	struct:viewstamp
server	./rpc/rpctest.cc	/^rpcs *server;  \/\/ server rpc object$/;"	v
service	./rpc/rpctest.cc	/^srv service;$/;"	v
set_primary	./rsm.cc	/^rsm::set_primary(unsigned vid)$/;"	f	class:rsm
set_rand_seed	./rpc/rpc.cc	/^void set_rand_seed()$/;"	f
set_reachable	./rpc/rpc.h	/^		void set_reachable(bool r) { reachable_ = r; }$/;"	f	class:rpcc
set_reachable	./rpc/rpc.h	/^	void set_reachable(bool r) { reachable_ = r; }$/;"	f	class:rpcs
set_state_transfer	./rsm.h	/^  void set_state_transfer(rsm_state_transfer *_stf) { stf = _stf; };$/;"	f	class:rsm
setattr	./yfs_client.cc	/^yfs_client::setattr(inum inum, fileinfo &fin) {$/;"	f	class:yfs_client
setn	./paxos.cc	/^proposer::setn()$/;"	f	class:proposer
simple_tests	./rpc/rpctest.cc	/^simple_tests(rpcc *c)$/;"	f
size	./extent_protocol.h	/^    unsigned int size;$/;"	m	struct:extent_protocol::attr
size	./fuse.cc	/^    size_t size;$/;"	m	struct:dirbuf	file:
size	./rpc/fifo.h	/^fifo<T>::size()$/;"	f	class:fifo
size	./rpc/marshall.h	/^		int size() { return _ind;}$/;"	f	class:marshall
size	./rpc/marshall.h	/^		int size() { return _sz;}$/;"	f	class:unmarshall
size	./yfs_client.h	/^    unsigned long long size;$/;"	m	struct:yfs_client::fileinfo
solong	./rpc/connection.h	/^			int solong; \/\/amount of bytes written or read so far$/;"	m	struct:connection::charbuf
spawn	./rsm_tester.pl	/^sub spawn {$/;"	s
spawn_config	./rsm_tester.pl	/^sub spawn_config {$/;"	s
spawn_ls	./rsm_tester.pl	/^sub spawn_ls {$/;"	s
srv	./rpc/rpctest.cc	/^class srv {$/;"	c	file:
srv_nonce	./rpc/marshall.h	/^	unsigned int srv_nonce;$/;"	m	struct:req_header
srv_nonce_	./rpc/rpc.h	/^		unsigned int srv_nonce_;$/;"	m	class:rpcc
stable	./paxos.h	/^  bool stable;$/;"	m	class:proposer
start_nodes	./rsm_tester.pl	/^sub start_nodes ($$){$/;"	s
startserver	./rpc/rpctest.cc	/^void startserver()$/;"	f
stat	./lock_client.cc	/^lock_client::stat(lock_protocol::lockid_t lid)$/;"	f	class:lock_client
stat	./lock_protocol.h	/^    stat$/;"	e	enum:lock_protocol::rpc_numbers
stat	./lock_server.cc	/^lock_server::stat(int clt, lock_protocol::lockid_t lid, int &r)$/;"	f	class:lock_server
stat	./lock_server_cache.cc	/^lock_server_cache::stat(lock_protocol::lockid_t lid, int &r)$/;"	f	class:lock_server_cache
state	./lock_server_cache.h	/^     lock_state state;$/;"	m	struct:lock_server_cache::lock_cache
state	./rsm_protocol.h	/^    std::string state;$/;"	m	struct:rsm_protocol::transferres
statetransfer	./rsm.cc	/^rsm::statetransfer(std::string m)$/;"	f	class:rsm
statetransferdone	./rsm.cc	/^rsm::statetransferdone(std::string m) {$/;"	f	class:rsm
static_max	./lang/algorithm.h	/^struct static_max$/;"	s
static_min	./lang/algorithm.h	/^struct static_min$/;"	s
status	./extent_protocol.h	/^  typedef int status;$/;"	t	class:extent_protocol
status	./lock_client_cache.h	/^  LOCKSTATUS status;$/;"	m	struct:CacheLock
status	./lock_protocol.h	/^  typedef int status;$/;"	t	class:lock_protocol
status	./lock_protocol.h	/^  typedef int status;$/;"	t	class:rlock_protocol
status	./paxos_protocol.h	/^  typedef int status;$/;"	t	class:paxos_protocol
status	./rsm_protocol.h	/^  typedef int status;$/;"	t	class:rsm_client_protocol
status	./rsm_protocol.h	/^  typedef int status;$/;"	t	class:rsm_protocol
status	./rsm_protocol.h	/^  typedef int status;$/;"	t	class:rsm_test_protocol
status	./yfs_client.h	/^  typedef int status;$/;"	t	class:yfs_client
stf	./rsm.h	/^  class rsm_state_transfer *stf;$/;"	m	class:rsm	typeref:class:rsm::rsm_state_transfer
str	./rpc/marshall.h	/^		std::string str() {$/;"	f	class:marshall
sync_cond	./rsm.h	/^  pthread_cond_t sync_cond;$/;"	m	class:rsm
sync_with_backups	./rsm.cc	/^rsm::sync_with_backups()$/;"	f	class:rsm
sync_with_primary	./rsm.cc	/^rsm::sync_with_primary()$/;"	f	class:rsm
sz	./rpc/connection.h	/^			int sz;$/;"	m	struct:connection::charbuf
sz	./rpc/rpc.h	/^		int sz;         \/\/ the size of reply buffer$/;"	m	struct:rpcs::reply_t
sz	./rpc/rpc.h	/^		int sz;$/;"	m	struct:rpcs::djob_t
table_mutex_	./lock_server.h	/^  std::mutex table_mutex_;$/;"	m	class:lock_server
takeJob	./rpc/thr_pool.cc	/^ThrPool::takeJob(job_t *j)$/;"	f	class:ThrPool
take_buf	./rpc/marshall.h	/^		void take_buf(char **b, int *s) {$/;"	f	class:marshall
take_buf	./rpc/marshall.h	/^		void take_buf(char **b, int *sz) {$/;"	f	class:unmarshall
take_content	./rpc/marshall.h	/^		void take_content(const std::string &s) {$/;"	f	class:unmarshall
take_in	./rpc/rpc.cc	/^unmarshall::take_in(unmarshall &another)$/;"	f	class:unmarshall
tcp	./rpc/connection.h	/^	int tcp;$/;"	m	struct:bundle
tcp_	./rpc/connection.h	/^		int tcp_; \/\/file desciptor for accepting connection$/;"	m	class:tcpsconn
tcpsconn	./rpc/connection.cc	/^tcpsconn::tcpsconn(chanmgr *m1, int port, int lossytest) $/;"	f	class:tcpsconn
tcpsconn	./rpc/connection.h	/^class tcpsconn {$/;"	c
test-lab-3-b	./GNUmakefile	/^test-lab-3-b=test-lab-3-b.c$/;"	m
test-lab-3-c	./GNUmakefile	/^test-lab-3-c=test-lab-3-c.c$/;"	m
test1	./lock_tester.cc	/^test1(void)$/;"	f
test2	./lock_tester.cc	/^test2(void *x) $/;"	f
test3	./lock_tester.cc	/^test3(void *x)$/;"	f
test4	./lock_tester.cc	/^test4(void *x)$/;"	f
test5	./lock_tester.cc	/^test5(void *x)$/;"	f
test_net_repairreq	./rsm.cc	/^rsm::test_net_repairreq(int heal, int &r)$/;"	f	class:rsm
testmarshall	./rpc/rpctest.cc	/^testmarshall()$/;"	f
testsvr	./rsm.h	/^  rpcs *testsvr;$/;"	m	class:rsm
th_	./rpc/connection.h	/^		pthread_t th_;$/;"	m	class:tcpsconn
th_	./rpc/pollmgr.h	/^		pthread_t th_;$/;"	m	class:PollMgr
th_	./rpc/thr_pool.h	/^		std::vector<pthread_t> th_;$/;"	m	class:ThrPool
timeout_failure	./rpc/rpc.h	/^		static const int timeout_failure = -1;$/;"	m	class:rpc_const
to	./rpc/rpc.h	/^			int to;$/;"	m	struct:rpcc::TO
to	./rpc/rpc.h	/^		static TO to(int x) { TO t; t.to = x; return t;}$/;"	f	class:rpcc
to_max	./rpc/rpc.cc	/^const rpcc::TO rpcc::to_max = { 120000 };$/;"	m	class:rpcc	file:
to_max	./rpc/rpc.h	/^		static const TO to_max;$/;"	m	class:rpcc
to_min	./rpc/rpc.cc	/^const rpcc::TO rpcc::to_min = { 1000 };$/;"	m	class:rpcc	file:
to_min	./rpc/rpc.h	/^		static const TO to_min;$/;"	m	class:rpcc
tprintf	./tprintf.h	4;"	d
transferdonereq	./rsm.cc	/^rsm::transferdonereq(std::string m, unsigned vid, int &)$/;"	f	class:rsm
transferdonereq	./rsm_protocol.h	/^    transferdonereq,$/;"	e	enum:rsm_protocol::rpc_numbers
transferreq	./rsm.cc	/^rsm::transferreq(std::string src, viewstamp last, unsigned vid, $/;"	f	class:rsm
transferreq	./rsm_protocol.h	/^    transferreq,$/;"	e	enum:rsm_protocol::rpc_numbers
transferres	./rsm_protocol.h	/^  struct transferres {$/;"	s	class:rsm_protocol
un	./rpc/rpc.h	/^			unmarshall *un;$/;"	m	struct:rpcc::caller
unlink	./yfs_client.cc	/^yfs_client::unlink(yfs_client::inum parent, const char *name)$/;"	f	class:yfs_client
unlink1	./test-lab-3-b.c	/^unlink1(const char *d, const char *f)$/;"	f
unlink1	./test-lab-3-c.c	/^unlink1(const char *d, const char *f)$/;"	f
unlinkn	./test-lab-3-b.c	/^unlinkn(const char *d, const char *prefix, int nf)$/;"	f
unlinkn	./test-lab-3-c.c	/^unlinkn(const char *d, const char *prefix, int nf)$/;"	f
unmarshal_args_failure	./rpc/rpc.h	/^		static const int unmarshal_args_failure = -2;$/;"	m	class:rpc_const
unmarshal_reply_failure	./rpc/rpc.h	/^		static const int unmarshal_reply_failure = -3;$/;"	m	class:rpc_const
unmarshall	./rpc/marshall.h	/^		unmarshall(): _buf(NULL),_sz(0),_ind(0),_ok(false) {}$/;"	f	class:unmarshall
unmarshall	./rpc/marshall.h	/^		unmarshall(char *b, int sz): _buf(b),_sz(sz),_ind(),_ok(true) {}$/;"	f	class:unmarshall
unmarshall	./rpc/marshall.h	/^		unmarshall(const std::string &s) : _buf(NULL),_sz(0),_ind(0),_ok(false) $/;"	f	class:unmarshall
unmarshall	./rpc/marshall.h	/^class unmarshall {$/;"	c
unpack	./rpc/rpc.cc	/^unmarshall::unpack(int *x)$/;"	f	class:unmarshall
unpack_reply_header	./rpc/marshall.h	/^		void unpack_reply_header(reply_header *h) {$/;"	f	class:unmarshall
unpack_req_header	./rpc/marshall.h	/^		void unpack_req_header(req_header *h) {$/;"	f	class:unmarshall
unwatch_fd	./rpc/pollmgr.cc	/^EPollAIO::unwatch_fd(int fd, poll_flag flag)$/;"	f	class:EPollAIO
unwatch_fd	./rpc/pollmgr.cc	/^SelectAIO::unwatch_fd(int fd, poll_flag flag)$/;"	f	class:SelectAIO
update_xid_rep	./rpc/rpc.cc	/^rpcc::update_xid_rep(unsigned int xid)$/;"	f	class:rpcc
updatestat	./rpc/rpc.cc	/^rpcs::updatestat(unsigned int proc)$/;"	f	class:rpcs
useful	./rpc/pollmgr.h	/^		static int useful;$/;"	m	class:PollMgr
useless	./rpc/pollmgr.h	/^		static int useless;$/;"	m	class:PollMgr
v	./paxos_protocol.h	/^    std::string v;$/;"	m	struct:paxos_protocol::acceptarg
v	./paxos_protocol.h	/^    std::string v;$/;"	m	struct:paxos_protocol::decidearg
v_a	./paxos.h	/^  std::string v_a;	\/\/ value of highest proposal accepted$/;"	m	class:acceptor
v_a	./paxos_protocol.h	/^    std::string v_a;$/;"	m	struct:paxos_protocol::prepareres
value	./config.cc	/^config::value(std::vector<std::string> m)$/;"	f	class:config
value	./lang/algorithm.h	/^    static const int value = A > B ? A : B;$/;"	m	struct:static_max
value	./paxos.h	/^  std::string value(unsigned instance) { return values[instance]; }$/;"	f	class:acceptor
values	./paxos.h	/^  std::map<unsigned,std::string> values;	\/\/ vals of each instance$/;"	m	class:acceptor
vc	./config.h	/^  config_view_change *vc;$/;"	m	class:config
verify_client_h	./lang/verify.h	4;"	d
vid	./config.h	/^  unsigned vid() { return myvid; }$/;"	f	class:config
vid	./rsm_protocol.h	/^  unsigned int vid;$/;"	m	struct:viewstamp
vid_commit	./rsm.h	/^  unsigned vid_commit;  \/\/ Latest view id that is known to rsm layer$/;"	m	class:rsm
vid_insync	./rsm.h	/^  unsigned vid_insync;  \/\/ The view id that this node is synchronizing for$/;"	m	class:rsm
viewstamp	./rsm_protocol.h	/^  viewstamp (unsigned int _vid = 0, unsigned int _seqno = 0) {$/;"	f	struct:viewstamp
viewstamp	./rsm_protocol.h	/^struct viewstamp {$/;"	s
wait_and_check_expected_view	./rsm_tester.pl	/^sub wait_and_check_expected_view($) {$/;"	s
wait_for_view_change	./rsm_tester.pl	/^sub wait_for_view_change {$/;"	s
wait_loop	./rpc/pollmgr.cc	/^PollMgr::wait_loop()$/;"	f	class:PollMgr
wait_ready	./rpc/pollmgr.cc	/^EPollAIO::wait_ready(std::vector<int> *readable, std::vector<int> *writable)$/;"	f	class:EPollAIO
wait_ready	./rpc/pollmgr.cc	/^SelectAIO::wait_ready(std::vector<int> *readable, std::vector<int> *writable)$/;"	f	class:SelectAIO
waiters_	./rpc/connection.h	/^		int waiters_;$/;"	m	class:connection
waitinglist	./lock_server_cache.h	/^     std::queue<std::string> waitinglist;$/;"	m	struct:lock_server_cache::lock_cache
waitpid_to	./rsm_tester.pl	/^sub waitpid_to {$/;"	s
watch_fd	./rpc/pollmgr.cc	/^EPollAIO::watch_fd(int fd, poll_flag flag)$/;"	f	class:EPollAIO
watch_fd	./rpc/pollmgr.cc	/^SelectAIO::watch_fd(int fd, poll_flag flag)$/;"	f	class:SelectAIO
wfds_	./rpc/pollmgr.h	/^		fd_set wfds_;$/;"	m	class:SelectAIO
wpdu_	./rpc/connection.h	/^		charbuf wpdu_;$/;"	m	class:connection
write	./yfs_client.cc	/^yfs_client::write(inum inum, std::string buf, off_t off, size_t nbytes)$/;"	f	class:yfs_client
write1	./test-lab-3-b.c	/^write1(const char *d, const char *f, int start, int n, char c)$/;"	f
write_cb	./rpc/connection.cc	/^connection::write_cb(int s)$/;"	f	class:connection
writeat	./test-lab-2-b.pl	/^sub writeat {$/;"	s
writeone	./test-lab-2-b.pl	/^sub writeone {$/;"	s
writepdu	./rpc/connection.cc	/^connection::writepdu()$/;"	f	class:connection
xid	./rpc/marshall.h	/^	int xid;$/;"	m	struct:reply_header
xid	./rpc/marshall.h	/^	int xid;$/;"	m	struct:req_header
xid	./rpc/rpc.h	/^			unsigned int xid;$/;"	m	struct:rpcc::caller
xid	./rpc/rpc.h	/^		unsigned int xid;$/;"	m	struct:rpcs::reply_t
xid	./rpc/rpc.h	/^                    int xid;$/;"	m	struct:rpcc::request
xid_	./rpc/rpc.h	/^		unsigned int xid_;$/;"	m	class:rpcc
xid_rep	./rpc/marshall.h	/^	int xid_rep;$/;"	m	struct:req_header
xid_rep_done_	./rpc/rpc.h	/^                int xid_rep_done_;$/;"	m	class:rpcc
xid_rep_window_	./rpc/rpc.h	/^		std::list<unsigned int> xid_rep_window_;$/;"	m	class:rpcc
xid_t	./lock_protocol.h	/^  typedef unsigned long long xid_t;$/;"	t	class:lock_protocol
xxstatus	./extent_protocol.h	/^  enum xxstatus { OK, RPCERR, NOENT, IOERR };$/;"	g	class:extent_protocol
xxstatus	./lock_protocol.h	/^  enum xxstatus { OK, RETRY, RPCERR, NOENT, IOERR };$/;"	g	class:lock_protocol
xxstatus	./lock_protocol.h	/^  enum xxstatus { OK, RPCERR };$/;"	g	class:rlock_protocol
xxstatus	./paxos_protocol.h	/^  enum xxstatus { OK, ERR };$/;"	g	class:paxos_protocol
xxstatus	./rsm_protocol.h	/^  enum xxstatus { OK, ERR, BUSY};$/;"	g	class:rsm_protocol
xxstatus	./rsm_protocol.h	/^  enum xxstatus { OK, ERR, NOTPRIMARY, BUSY};$/;"	g	class:rsm_client_protocol
xxstatus	./rsm_protocol.h	/^  enum xxstatus { OK, ERR};$/;"	g	class:rsm_test_protocol
xxstatus	./yfs_client.h	/^  enum xxstatus { OK, RPCERR, NOENT, IOERR, EXIST };$/;"	g	class:yfs_client
yfs	./fuse.cc	/^yfs_client *yfs;$/;"	v
yfs_client	./GNUmakefile	/^yfs_client=yfs_client.cc extent_client.cc fuse.cc$/;"	m
yfs_client	./yfs_client.cc	/^yfs_client::yfs_client(std::string extent_dst, std::string lock_dst)$/;"	f	class:yfs_client
yfs_client	./yfs_client.h	/^class yfs_client {$/;"	c
yfs_client_h	./yfs_client.h	2;"	d
yyy	./rpc/method_thread.h	/^				static void *yyy(void *vvv) {$/;"	f	class:__anon3::XXX
~EPollAIO	./rpc/pollmgr.cc	/^EPollAIO::~EPollAIO()$/;"	f	class:EPollAIO
~PollMgr	./rpc/pollmgr.cc	/^PollMgr::~PollMgr()$/;"	f	class:PollMgr
~ScopedLock	./rpc/slock.h	/^		~ScopedLock() {$/;"	f	struct:ScopedLock
~SelectAIO	./rpc/pollmgr.cc	/^SelectAIO::~SelectAIO()$/;"	f	class:SelectAIO
~ThrPool	./rpc/thr_pool.cc	/^ThrPool::~ThrPool()$/;"	f	class:ThrPool
~acceptor	./paxos.h	/^  ~acceptor() {};$/;"	f	class:acceptor
~aio_callback	./rpc/pollmgr.h	/^		virtual ~aio_callback() {}$/;"	f	class:aio_callback
~aio_mgr	./rpc/pollmgr.h	/^		virtual ~aio_mgr() {}$/;"	f	class:aio_mgr
~caller	./rpc/rpc.cc	/^rpcc::caller::~caller()$/;"	f	class:rpcc::caller
~chanmgr	./rpc/connection.h	/^		virtual ~chanmgr() {}$/;"	f	class:chanmgr
~config_view_change	./config.h	/^  virtual ~config_view_change() {};$/;"	f	class:config_view_change
~connection	./rpc/connection.cc	/^connection::~connection()$/;"	f	class:connection
~fifo	./rpc/fifo.h	/^fifo<T>::~fifo()$/;"	f	class:fifo
~handle	./handle.cc	/^handle::~handle() $/;"	f	class:handle
~handler	./rpc/rpc.h	/^		virtual ~handler() { }$/;"	f	class:handler
~lock_client	./lock_client.h	/^  virtual ~lock_client() {};$/;"	f	class:lock_client
~lock_client_cache	./lock_client_cache.h	/^  virtual ~lock_client_cache() {};$/;"	f	class:lock_client_cache
~lock_release_user	./lock_client_cache.h	/^  virtual ~lock_release_user() {};$/;"	f	class:lock_release_user
~lock_server	./lock_server.h	/^  ~lock_server() {};$/;"	f	class:lock_server
~marshall	./rpc/marshall.h	/^		~marshall() { $/;"	f	class:marshall
~paxos_change	./paxos.h	/^  virtual ~paxos_change() {};$/;"	f	class:paxos_change
~proposer	./paxos.h	/^  ~proposer() {};$/;"	f	class:proposer
~rpcc	./rpc/rpc.cc	/^rpcc::~rpcc()$/;"	f	class:rpcc
~rpcs	./rpc/rpc.cc	/^rpcs::~rpcs()$/;"	f	class:rpcs
~rsm	./rsm.h	/^  ~rsm() {};$/;"	f	class:rsm
~rsm_state_transfer	./rsm_state_transfer.h	/^  virtual ~rsm_state_transfer() {};$/;"	f	class:rsm_state_transfer
~rsmtest_client	./rsmtest_client.h	/^  virtual ~rsmtest_client() {};$/;"	f	class:rsmtest_client
~tcpsconn	./rpc/connection.cc	/^tcpsconn::~tcpsconn()$/;"	f	class:tcpsconn
~unmarshall	./rpc/marshall.h	/^		~unmarshall() {$/;"	f	class:unmarshall
